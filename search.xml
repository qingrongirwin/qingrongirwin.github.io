<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>产品经理成长之路01</title>
    <url>/2020/06/07/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/</url>
    <content><![CDATA[<h1 id="产品经理成长之路01"><a href="#产品经理成长之路01" class="headerlink" title="产品经理成长之路01"></a>产品经理成长之路01</h1><h3 id="用产品画布思考问题"><a href="#用产品画布思考问题" class="headerlink" title="用产品画布思考问题"></a>用产品画布思考问题</h3><img src="/2020/06/07/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/01.jpg" srcset="/img/loading.gif" class title="产品画布">

<h3 id="什么是产品的生命周期？"><a href="#什么是产品的生命周期？" class="headerlink" title="什么是产品的生命周期？"></a>什么是产品的生命周期？</h3><div class="hljs"><pre><code class="hljs plain">从进入市场一直到退出市场为止所经历的整个过程，这个过程会因为产品的不同阶段，有不同的表现</code></pre></div>

<img src="/2020/06/07/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/02.png" srcset="/img/loading.gif" class title="互联网产品的生命周期">

<h3 id="如何判别我的产品属于哪个周期？"><a href="#如何判别我的产品属于哪个周期？" class="headerlink" title="如何判别我的产品属于哪个周期？"></a>如何判别我的产品属于哪个周期？</h3><ol>
<li>首先，看活跃用户量趋势，平稳、向上拉升还是往下掉？</li>
<li>其次看时间段 ，一般18个月后，产品都会进入成长期</li>
</ol>
<p><strong>提醒</strong>：看活跃用户量时，尽可能分离外部推广带来的“增肥效应”</p>
<img src="/2020/06/07/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/03.png" srcset="/img/loading.gif" class title="案例图">

<h3 id="当你不是产品的资深用户怎么办？"><a href="#当你不是产品的资深用户怎么办？" class="headerlink" title="当你不是产品的资深用户怎么办？"></a>当你不是产品的资深用户怎么办？</h3><p>如果你不是现有产品的资深用户，你将很难去了解核心用户的需求以及行为路径，以至于在之后的产品迭代过程中无法匹配到产品需求和用户需求的“一致性”。你应该深入到用户群体里面去，让用户教育你</p>
<h3 id="安全必须第一吗？"><a href="#安全必须第一吗？" class="headerlink" title="安全必须第一吗？"></a>安全必须第一吗？</h3><p>产品都不是完美的，在产品处于<strong>稳定期或者可控范围</strong>内，不要为了1%的用户去影响99%的用户</p>
<h3 id="要数量还是要质量？"><a href="#要数量还是要质量？" class="headerlink" title="要数量还是要质量？"></a>要数量还是要质量？</h3><p>这取决于当前产品的生命周期处于哪个阶段</p>
<ul>
<li>当产品处于探索期或者成长期的时候，更应该注重拉新或者新增用户。在早起要对产品功能进行迭代和优化，前提就是要有用户，总不能靠自己一个人去想想怎么迭代产品</li>
<li>当产品处于成熟期或者衰退期的时候，产品经理应该更关注产品中的“用户留存率”以及“用户流失率”。如何通过与运营的配合，使用运营方式手段，用“短期价值”和“长期价值”留住用户，这才是PM应该重点关注的地方。</li>
</ul>
<h3 id="产品迭代策略"><a href="#产品迭代策略" class="headerlink" title="产品迭代策略"></a>产品迭代策略</h3><p>四个时期不同的策略</p>
<img src="/2020/06/07/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/04.png" srcset="/img/loading.gif" class title="产品迭代策略图">

<p>相应的用户运营现象和策略</p>
<img src="/2020/06/07/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/05.png" srcset="/img/loading.gif" class title="用户运营现象与策略图">]]></content>
      <categories>
        <category>产品经理</category>
      </categories>
      <tags>
        <tag>产品经理成长</tag>
      </tags>
  </entry>
  <entry>
    <title>eos节点读取解析</title>
    <url>/2019/12/30/eos%E8%8A%82%E7%82%B9%E8%AF%BB%E5%8F%96%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span>
<span class="hljs-keyword">import</span> xlrd
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">import</span> io
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> re
<span class="hljs-keyword">import</span> xlwt  <span class="hljs-comment"># 导入模块</span>

url_list=[]  <span class="hljs-comment">#存储拼接后的网址</span>
data=[]     <span class="hljs-comment">#存储解析后的json数据</span>
ip_all=[]       <span class="hljs-comment">#存储ip</span>

wb = xlwt.Workbook(encoding=<span class="hljs-string">'ascii'</span>)  <span class="hljs-comment"># 创建新的Excel（新的workbook），建议还是用ascii编码</span>
ws = wb.add_sheet(<span class="hljs-string">'result'</span>)  <span class="hljs-comment"># 创建新的表单result</span>


<span class="hljs-comment">#从excel读取节点名</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_excel</span><span class="hljs-params">(filename)</span>:</span>

    data=xlrd.open_workbook(filename)           <span class="hljs-comment">#打开execel</span>
    table=data.sheet_by_index(<span class="hljs-number">0</span>)                <span class="hljs-comment">#读取表1</span>
    print(<span class="hljs-string">"该excel表一共有"</span>+str(table.nrows)+<span class="hljs-string">"行"</span>)                          <span class="hljs-comment">#打印行数</span>
    print(<span class="hljs-string">"该excel表一共有"</span>+str(table.ncols)+<span class="hljs-string">"列"</span>)                          <span class="hljs-comment">#打印列数</span>

    <span class="hljs-keyword">for</span> i  <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,table.nrows):
        url=table.cell(i,<span class="hljs-number">1</span>).value               <span class="hljs-comment">#读取第一列的每一个值</span>
        ws.write(i, <span class="hljs-number">0</span>, label=url)
        url_list.append(url)                    <span class="hljs-comment">#写入到列表里</span>


<span class="hljs-comment">#进行拼接成以下格式，然后解析</span>
<span class="hljs-comment">#https://eospark.com/api/v2/bp?account=eoshuobipool&amp;language=zh</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">res_url</span><span class="hljs-params">(list)</span>:</span>
    headers = &#123;
        <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36'</span>
    &#125;

    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding=<span class="hljs-string">'gb18030'</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list:
        st =<span class="hljs-string">"https://eospark.com/api/v2/bp?account="</span>+str(i)+<span class="hljs-string">"&amp;language=zh"</span>
        res = requests.get(st, headers=headers)
        print(<span class="hljs-string">"****************************************"</span>)
      <span class="hljs-comment">#  print(res.text)</span>
        data.append(res.text)
    print(<span class="hljs-string">"successful"</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ip138</span><span class="hljs-params">(tes_url)</span>:</span>
    headers = &#123;
        <span class="hljs-string">'user-agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36'</span>
    &#125;

    url = <span class="hljs-string">"https://site.ip138.com/"</span>+tes_url

    res = requests.get(url, headers=headers)
    <span class="hljs-comment"># 通过Response对象的text方法获取网页的文本信息</span>
    <span class="hljs-comment">#print(res.text)</span>

    pattern = re.compile(<span class="hljs-string">r'((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;'</span>)
    str = res.text
    <span class="hljs-comment"># print(pattern.search(str))</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> pattern.search(str).group(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>


<span class="hljs-comment">#正则匹配出解析出来的json文件里面的节点接入点的网址</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">re_url</span><span class="hljs-params">(list)</span>:</span>
    pat_url = <span class="hljs-string">'api_.*?([a-zA-z]+://[^\s]*)\''</span>
    patt_url = <span class="hljs-string">'ssl_.*?([a-zA-z]+://[^\s]*)\'&#125;'</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list:
        ip = []

        data=str(json.loads(i))
        result_url = re.findall(pattern=pat_url, string=data)
        resultt_url = re.findall(pattern=patt_url, string=data)
        print(result_url)
        <span class="hljs-keyword">for</span> url,urlt <span class="hljs-keyword">in</span> zip(result_url,resultt_url):
            url=url.split(<span class="hljs-string">"//"</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">":"</span>)[<span class="hljs-number">0</span>]
           <span class="hljs-comment"># print(url)</span>
            ip.append(ip138(url))

            urlt=urlt.split(<span class="hljs-string">"//"</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">":"</span>)[<span class="hljs-number">0</span>]
          <span class="hljs-comment">#  print(urlt)</span>
            ip.append(ip138(urlt))
            print(<span class="hljs-string">"*******"</span>)

        <span class="hljs-comment">#print(resultt_url)</span>
        print(<span class="hljs-string">"+++++++++++++++++++++++++++"</span>)
        <span class="hljs-comment">#print(ip)</span>
        print(<span class="hljs-string">"++++++++++++++"</span>)
        ip_all.append(ip)



<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:
    filename=<span class="hljs-string">"EOSnodes.xlsx"</span>
    read_excel(filename)
    res_url(url_list)
    re_url(data)
    <span class="hljs-keyword">for</span> i ,ip <span class="hljs-keyword">in</span> zip(range(<span class="hljs-number">0</span>,len(ip_all)),ip_all):
        ws.write(i,<span class="hljs-number">1</span>, label=ip)  <span class="hljs-comment"># 依次将解析的ip存入excel表里面</span>

    wb.save(<span class="hljs-string">'result.xls'</span>)
    print(<span class="hljs-string">"successful"</span>)


<span class="hljs-string">"""
该文件的功能是解析eos节点的ip地址
EOSnodes.xlsx里面的内容为各节点名称，
之后所有ip存入result.xls表里
"""</span></code></pre></div>

]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
      <tags>
        <tag>python脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>alexa榜单爬取</title>
    <url>/2019/12/30/alexa%E6%A6%9C%E5%8D%95%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<p>爬取alexa网址榜单</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#coding=gbk</span>
<span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> Request, urlopen,ProxyHandler,build_opener
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> io
<span class="hljs-keyword">import</span> re
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> re
<span class="hljs-keyword">import</span> xlrd
<span class="hljs-comment">#import xlutils.copy</span>
<span class="hljs-keyword">import</span> xlrd
<span class="hljs-keyword">import</span> xlwt
<span class="hljs-keyword">import</span> random

filename=<span class="hljs-string">"url.xls"</span>

url = <span class="hljs-string">'http://www.alexa.cn/siterank'</span>

USER_AGENTS = [
    <span class="hljs-string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)"</span>,
    <span class="hljs-string">"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)"</span>,
    <span class="hljs-string">"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)"</span>,
    <span class="hljs-string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)"</span>,
    <span class="hljs-string">"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6"</span>,
    <span class="hljs-string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1"</span>,
    <span class="hljs-string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0"</span>,
    <span class="hljs-string">"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5"</span>
]

proxy_list = [
    &#123;<span class="hljs-string">"http"</span>: <span class="hljs-string">"	183.146.157.125:9999"</span>&#125;,
    &#123;<span class="hljs-string">"http"</span>: <span class="hljs-string">"117.69.51.250:9999"</span>&#125;,
    &#123;<span class="hljs-string">"http"</span>: <span class="hljs-string">"183.166.133.82:9999"</span>&#125;,
    &#123;<span class="hljs-string">"http"</span>: <span class="hljs-string">"223.199.25.127:9999"</span>&#125;,
    &#123;<span class="hljs-string">"http"</span>: <span class="hljs-string">"223.199.27.141:999"</span>&#125;
]

headers=&#123;<span class="hljs-string">'User-Agent'</span>:<span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36"</span>&#125;
sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=<span class="hljs-string">'gb18030'</span>)

<span class="hljs-comment">#爬取网页</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_url</span><span class="hljs-params">(url)</span>:</span>

    request = Request(url=url, headers=headers)
    html = urlopen(request).read()
    htmltext=html.decode(<span class="hljs-string">"utf-8"</span>)
    <span class="hljs-keyword">return</span> htmltext

<span class="hljs-comment">#正则匹配</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pat_result</span><span class="hljs-params">(htmltext)</span>:</span>
    <span class="hljs-comment">#pat='content="([a-zA-z]+://[^\s]*)"'</span>
    pat_url=<span class="hljs-string">r'href="([a-zA-z]+://[^\s]*)"&gt;访问站点&lt;/a&gt;'</span>
    <span class="hljs-comment">#result=re.findall(pattern=pat,string=htmltext)</span>
    result_url=re.findall(pattern=pat_url,string=htmltext)
    <span class="hljs-comment">#print(result)</span>
    <span class="hljs-keyword">return</span> (result_url)
    <span class="hljs-comment">#print(len(result_url))</span>





<span class="hljs-comment">#写入excel</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_excel</span><span class="hljs-params">(i,url)</span>:</span>
    ws.write(i,<span class="hljs-number">0</span>,label=url)            <span class="hljs-comment">#在第一列写入域名</span>
    wb.save(filename)

<span class="hljs-comment">#读取excel</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_excel</span><span class="hljs-params">(filename)</span>:</span>
    data=xlrd.open_workbook(filename)           <span class="hljs-comment">#打开execel</span>
    table=data.sheet_by_index(<span class="hljs-number">0</span>)                <span class="hljs-comment">#读取表1</span>
    <span class="hljs-keyword">return</span> table.nrows                          <span class="hljs-comment">#打印行数</span>



<span class="hljs-comment"># def write_excel_xls_append(file,value):</span>
<span class="hljs-comment">#     index = len(value)  # 获取需要写入数据的行数</span>
<span class="hljs-comment">#     workbook = xlrd.open_workbook(file)  # 打开工作簿</span>
<span class="hljs-comment">#     sheets = workbook.sheet_names()  # 获取工作簿中的所有表格</span>
<span class="hljs-comment">#     worksheet = workbook.sheet_by_name(sheets[0])  # 获取工作簿中所有表格中的的第一个表格</span>
<span class="hljs-comment">#     rows_old = worksheet.nrows  # 获取表格中已存在的数据的行数</span>
<span class="hljs-comment">#     new_workbook = copy(workbook)  # 将xlrd对象拷贝转化为xlwt对象</span>
<span class="hljs-comment">#     new_worksheet = new_workbook.get_sheet(0)  # 获取转化后工作簿中的第一个表格</span>
<span class="hljs-comment">#     for i in range(0, index):</span>
<span class="hljs-comment">#         for j in range(0, len(value[i])):</span>
<span class="hljs-comment">#             new_worksheet.write(i+rows_old, j, value[i][j])  # 追加写入数据，注意是从i+rows_old行开始写入</span>
<span class="hljs-comment">#     new_workbook.save(file)  # 保存工作簿</span>


<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">try</span>:
        wb = xlwt.Workbook(encoding=<span class="hljs-string">'ascii'</span>)
        ws = wb.add_sheet(filename)  <span class="hljs-comment"># 创建新的表单</span>
        ws.write(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, label=<span class="hljs-string">'域名'</span>)  <span class="hljs-comment"># 在（0，0）加入域名</span>

        url_list=[]
     <span class="hljs-comment">#   url_list.extend(pat_result(get_url(url)))</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">51</span>,<span class="hljs-number">101</span>):
           url_list.extend(pat_result(get_url(url+<span class="hljs-string">"/"</span>+str(i))))
           print(<span class="hljs-string">"已经爬取完第"</span>+str(i)+<span class="hljs-string">"页"</span>)
    <span class="hljs-comment">#       user_agent = random.choice(USER_AGENTS)</span>
    <span class="hljs-comment">#       headers = &#123;'User-Agent': user_agent&#125;</span>


           time.sleep(<span class="hljs-number">60</span>)

        print(len(url_list))
        print(url_list)
        <span class="hljs-comment">#</span>
        <span class="hljs-comment"># ws = xlutils.copy.copy(data)</span>
        <span class="hljs-comment"># table = ws.get_sheet(0)</span>

        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(url_list)):
            write_excel(i+<span class="hljs-number">1</span>,url_list[i])

        print(<span class="hljs-string">"写入完成"</span>)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        print(e)
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">finally</span>:
        wb.save(filename)


<span class="hljs-string">"""
爬取alexa网址榜单，存储到url.xls
"""</span></code></pre></div>

]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
      <tags>
        <tag>python脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>ipv6地址解析</title>
    <url>/2019/12/30/ipv6%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>传入域名，通过nslookup命令解析出ipv6地址</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span>
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> re
<span class="hljs-keyword">import</span> xlwt
<span class="hljs-keyword">import</span> xlrd

<span class="hljs-comment">#定义列表保存域名</span>
list_url=[]


<span class="hljs-comment">#读取ecxcel</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_excel</span><span class="hljs-params">(filename)</span>:</span>

    data=xlrd.open_workbook(filename)           <span class="hljs-comment">#打开execel</span>
    table=data.sheet_by_index(<span class="hljs-number">0</span>)                <span class="hljs-comment">#读取表1</span>
    print(table.nrows)                          <span class="hljs-comment">#打印行数</span>
    print(table.ncols)                          <span class="hljs-comment">#打印列数</span>

    <span class="hljs-keyword">for</span> i  <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,table.nrows):
        url=table.cell(i,<span class="hljs-number">0</span>).value               <span class="hljs-comment">#读取第一列的每一个值</span>
        list_url.append(url)                    <span class="hljs-comment">#写入到列表里</span>


<span class="hljs-comment"># 创建新的Excel（新的workbook），建议还是用ascii编码</span>
wb = xlwt.Workbook(encoding=<span class="hljs-string">'ascii'</span>)
ws = wb.add_sheet(<span class="hljs-string">'ipv6_result'</span>)        <span class="hljs-comment"># 创建新的表单ipv6_result</span>
ws.write(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, label=<span class="hljs-string">'ipv6'</span>)            <span class="hljs-comment"># 在（0,1）加入ipv6</span>
ws.write(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,label=<span class="hljs-string">'域名'</span>)              <span class="hljs-comment">#在（0，0）加入域名</span>

<span class="hljs-comment">#写入excel</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_excel</span><span class="hljs-params">(url,ipv6_add,i)</span>:</span>
    ws.write(i,<span class="hljs-number">0</span>,label=url)            <span class="hljs-comment">#在第一列写入域名</span>
    ws.write(i,<span class="hljs-number">1</span>,label=ipv6_add)      <span class="hljs-comment">#在第二列写入ipv6地址</span>
    wb.save(<span class="hljs-string">'ipv6_result.xls'</span>)


<span class="hljs-comment">#解析ipv6地址</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cmd_nslookup</span><span class="hljs-params">(net)</span>:</span>
    net=net.split(<span class="hljs-string">"//"</span>)
    net=net[<span class="hljs-number">1</span>]      <span class="hljs-comment">#去掉http://</span>
    s=os.popen(<span class="hljs-string">"nslookup "</span>+net)
    s=s.read()
  <span class="hljs-comment">#  print(s)</span>

    <span class="hljs-comment">#正则匹配</span>
    pat=<span class="hljs-string">'Addresses:(.*?)\n'</span>
    result = re.findall(pattern=pat, string=s)

    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">if</span> result==<span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-string">'.'</span><span class="hljs-keyword">in</span> result[<span class="hljs-number">0</span>]:         <span class="hljs-comment">#以.来判断ipv4还是ipv6</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>



<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:

    <span class="hljs-comment"># url="www.ccbtrust.com.cn"</span>
    <span class="hljs-comment"># t=cmd_nslookup(net=url)</span>
    <span class="hljs-comment"># print(t)</span>
    <span class="hljs-comment"># write_excel(t,1)</span>
    <span class="hljs-comment"># print("写入完成")</span>

    filename=<span class="hljs-string">"url.xls"</span>         <span class="hljs-comment">#要读取的excel表</span>
    read_excel(filename)            <span class="hljs-comment">#读取域名</span>
    <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(list_url)):
        url=list_url[count]
        print(url)
        ipv6_add=cmd_nslookup(net=url)      <span class="hljs-comment">#解析ipv6</span>
        print(ipv6_add)
        print(<span class="hljs-string">"解析完成第"</span> + str(count+<span class="hljs-number">1</span>) + <span class="hljs-string">"个地址"</span>)
        write_excel(url,ipv6_add,count+<span class="hljs-number">1</span>)           <span class="hljs-comment">#将域名和ipv6地址写入excel</span>
        print(<span class="hljs-string">"写入完成第"</span> + str(count+<span class="hljs-number">1</span>)+ <span class="hljs-string">"个地址\n"</span>)

    print(<span class="hljs-string">"全部域名解析写入完成"</span>)

<span class="hljs-string">"""
解析域名的ipv6地址，用的是电脑网卡设置的DNS服务器，可自行再电脑网络设置中更改服务器地址就行
传入的文件url.xls的内容为域名地址，最终生成一个ipv6_result的excel表格
"""</span></code></pre></div>

]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
      <tags>
        <tag>python脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>解析ip地址</title>
    <url>/2019/12/30/%E8%A7%A3%E6%9E%90ip%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>传入ip地址，然后解析出ip所属的国家、省份、城市，类似于ip138网站的解析</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span>
<span class="hljs-keyword">import</span> xlrd

ip_list=[]


<span class="hljs-comment">#解析ip地址，传入ip即可</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_peer_detail</span><span class="hljs-params">(ip)</span>:</span>
    <span class="hljs-keyword">import</span> subprocess
    cmd = <span class="hljs-string">'java -jar IPLocJar.jar '</span> + ip
    detail = &#123;&#125;
    p = subprocess.Popen(
        cmd, shell=<span class="hljs-literal">True</span>, stdout=subprocess.PIPE, universal_newlines=<span class="hljs-literal">True</span>)

    p.wait()

    result = p.stdout.readlines()

    detail[<span class="hljs-string">'country'</span>] = result[<span class="hljs-number">0</span>].strip()
    detail[<span class="hljs-string">'province'</span>] = result[<span class="hljs-number">1</span>].strip()
    detail[<span class="hljs-string">'city'</span>] = result[<span class="hljs-number">2</span>].strip()
 <span class="hljs-comment">#   detail['latitude'] = result[5].strip()</span>
<span class="hljs-comment">#    detail['longitude'] = result[6].strip()</span>

    <span class="hljs-keyword">return</span> detail

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_excel</span><span class="hljs-params">(filename)</span>:</span>

    data=xlrd.open_workbook(filename)           <span class="hljs-comment">#打开execel</span>
    table=data.sheet_by_index(<span class="hljs-number">0</span>)                <span class="hljs-comment">#读取表1</span>
    print(<span class="hljs-string">"该excel表一共有"</span>+str(table.nrows)+<span class="hljs-string">"行"</span>)                          <span class="hljs-comment">#打印行数</span>
    print(<span class="hljs-string">"该excel表一共有"</span>+str(table.ncols)+<span class="hljs-string">"列"</span>)                          <span class="hljs-comment">#打印列数</span>

    <span class="hljs-keyword">for</span> i  <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,table.nrows):
        ip=table.cell(i,<span class="hljs-number">2</span>).value               <span class="hljs-comment">#读取第一列的每一个值</span>
        ip_list.append(ip)                    <span class="hljs-comment">#写入到列表里</span>


<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:
    filename=<span class="hljs-string">'EOSnodes.xlsx'</span>
    iplist=[]
    read_excel(filename)
    <span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> ip_list:
        <span class="hljs-comment">#print(ip)</span>
        <span class="hljs-comment">#print(type(ip))</span>
        <span class="hljs-keyword">if</span> ip.isspace()==<span class="hljs-literal">True</span>:
            print(<span class="hljs-string">"None"</span>)
            <span class="hljs-keyword">continue</span>

        dic=get_peer_detail(ip)
        print(dic[<span class="hljs-string">'country'</span>])       <span class="hljs-comment">#打印出国家</span>
    print(<span class="hljs-string">"************************************"</span>)
    <span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> ip_list:

        <span class="hljs-keyword">if</span> ip.isspace()==<span class="hljs-literal">True</span>:
            print(<span class="hljs-string">"None"</span>)
            <span class="hljs-keyword">continue</span>
            <span class="hljs-comment"># print(ip)</span>
        dic = get_peer_detail(ip)
        print(dic[<span class="hljs-string">'province'</span>])      <span class="hljs-comment">#打印出省份</span>
    print(<span class="hljs-string">"************************************"</span>)
    <span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> ip_list:
        <span class="hljs-keyword">if</span> ip.isspace()==<span class="hljs-literal">True</span>:
            print(<span class="hljs-string">"None"</span>)
            <span class="hljs-keyword">continue</span>
                <span class="hljs-comment"># print(ip)</span>
        dic = get_peer_detail(ip)
        print(dic[<span class="hljs-string">'city'</span>])          <span class="hljs-comment">#打印出城市</span>


    print(<span class="hljs-string">"successful"</span>)

<span class="hljs-string">"""
解析ip，生成ip所在的国家、省份及城市，
这个要配合IPLocJar.jar，把这个放到当前目录下即可
然后需要配置java的SDK才能使用
"""</span></code></pre></div>

]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
      <tags>
        <tag>python脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>从excel读取数据插入数据库</title>
    <url>/2019/12/30/%E4%BB%8Eexcel%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>从excel中读取每一列数据，然后对应的数据库创建列，写入进去</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#conding=utf-8</span>
<span class="hljs-keyword">import</span> pymysql
<span class="hljs-keyword">import</span> xlrd
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> io
<span class="hljs-comment">#sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding='utf8') #改变标准输出的默认编码</span>

usermessage=&#123;
    <span class="hljs-string">'host'</span>:<span class="hljs-string">'服务器地址'</span>,
    <span class="hljs-string">'user'</span>:<span class="hljs-string">'用户名'</span>,
    <span class="hljs-string">'passwd'</span>:<span class="hljs-string">'密码'</span>,
    <span class="hljs-string">'db'</span>:<span class="hljs-string">'数据库名称'</span>,
&#125;

<span class="hljs-comment">#定义字典保存域名、描述、ipv6地址</span>
dic_data=&#123;<span class="hljs-string">'name'</span>:[],<span class="hljs-string">'organization'</span>:[],<span class="hljs-string">'type'</span>:[],<span class="hljs-string">'country'</span>:[],<span class="hljs-string">'province'</span>:[],<span class="hljs-string">'city'</span>:[],<span class="hljs-string">'ip'</span>:[],<span class="hljs-string">'port'</span>:[],<span class="hljs-string">'update_time'</span>:[]&#125;

<span class="hljs-comment">#连接数据库，执行操作</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mysql_db</span><span class="hljs-params">(usermessage,dicdata,port= <span class="hljs-number">3306</span>,charset = <span class="hljs-string">'utf8'</span>)</span>:</span>
    <span class="hljs-comment">#建立连接</span>
    count=<span class="hljs-number">1</span>
    coon = pymysql.connect(**usermessage)

    <span class="hljs-comment">#建立游标</span>
    cur = coon.cursor()
    <span class="hljs-keyword">for</span> name,org,type,country,province,city,ip,port <span class="hljs-keyword">in</span> zip(dicdata[<span class="hljs-string">'name'</span>],dicdata[<span class="hljs-string">'organization'</span>],dicdata[<span class="hljs-string">'type'</span>],dicdata[<span class="hljs-string">'country'</span>],dicdata[<span class="hljs-string">'province'</span>],dicdata[<span class="hljs-string">'city'</span>],dicdata[<span class="hljs-string">'ip'</span>],dicdata[<span class="hljs-string">'port'</span>]):
        time=<span class="hljs-string">"2019-12-24 16:54:24"</span>
        <span class="hljs-comment">#执行sql操作</span>
        sql_insert=<span class="hljs-string">"insert into xml_nodes(name,organization,type,country,province,city,ip,port,update_time) values (%s,%s,%s,%s,%s,%s,%s,%s,%s)"</span>
        val=(name,org,type,country,province,city,ip,port,time)
        <span class="hljs-comment"># print(sql_insert,val)</span>
        <span class="hljs-comment"># exit(0)</span>
        cur.execute(sql_insert,val)
        coon.commit()

        print(<span class="hljs-string">"已插入第"</span>+str(count)+<span class="hljs-string">"条数据"</span>)
        count += <span class="hljs-number">1</span>

    <span class="hljs-comment">#关闭游标，关闭连接</span>
    cur.close()
    coon.close()

<span class="hljs-comment">#读取ecxcel</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_excel</span><span class="hljs-params">(filename)</span>:</span>

    data=xlrd.open_workbook(filename)           <span class="hljs-comment">#打开execel</span>
    table=data.sheet_by_index(<span class="hljs-number">0</span>)                <span class="hljs-comment">#读取表1</span>
    print(<span class="hljs-string">"该excel表一共有"</span>+str(table.nrows)+<span class="hljs-string">"行"</span>)                          <span class="hljs-comment">#打印行数</span>
    print(<span class="hljs-string">"该excel表一共有"</span>+str(table.ncols)+<span class="hljs-string">"列"</span>)                          <span class="hljs-comment">#打印列数</span>

    <span class="hljs-keyword">for</span> i  <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,table.nrows):
        name=table.cell(i,<span class="hljs-number">0</span>).value               <span class="hljs-comment">#读取第一列的每一个值</span>
        dic_data[<span class="hljs-string">'name'</span>].append(name)                    <span class="hljs-comment">#写入到列表里</span>
        org=table.cell(i,<span class="hljs-number">1</span>).value
        dic_data[<span class="hljs-string">'organization'</span>].append(org)
        type=table.cell(i,<span class="hljs-number">2</span>).value
        dic_data[<span class="hljs-string">'type'</span>].append(type)
        country = table.cell(i, <span class="hljs-number">3</span>).value
        dic_data[<span class="hljs-string">'country'</span>].append(country)
        province = table.cell(i, <span class="hljs-number">4</span>).value
        dic_data[<span class="hljs-string">'province'</span>].append(province)
        city = table.cell(i, <span class="hljs-number">5</span>).value
        dic_data[<span class="hljs-string">'city'</span>].append(city)
        ip = table.cell(i, <span class="hljs-number">6</span>).value
        dic_data[<span class="hljs-string">'ip'</span>].append(ip)
        port= table.cell(i, <span class="hljs-number">7</span>).value
        dic_data[<span class="hljs-string">'port'</span>].append(port)
        update_time = table.cell(i, <span class="hljs-number">8</span>).value
        dic_data[<span class="hljs-string">'update_time'</span>].append(update_time)






<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:
    filename=<span class="hljs-string">"XLM.xlsx"</span>
    read_excel(filename)
    mysql_db(usermessage,dic_data)

    print(<span class="hljs-string">"successful"</span>)


<span class="hljs-string">"""
使用说明：
16行定义的字典用来保存从excel中读取的每一列的元素，根据excel表的列表名修改
同时记得26行for循环里的元素
29行、30行的插入语句，根据数据库设计的不同进行修改
51~60行，按照excel的列表名进行修改
77行，改成要导入的excel表名路径
"""</span></code></pre></div>

]]></content>
      <categories>
        <category>python脚本</category>
      </categories>
      <tags>
        <tag>python脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_25复杂链表的复制</title>
    <url>/2019/12/09/%E5%89%91%E6%8C%87offer-25%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><img src="/2019/12/09/%E5%89%91%E6%8C%87offer-25%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/1.png" srcset="/img/loading.gif" class title="picture">



<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-comment"># class RandomListNode:</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.label = x</span>
<span class="hljs-comment">#         self.next = None</span>
<span class="hljs-comment">#         self.random = None</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-comment"># 返回 RandomListNode</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Clone</span><span class="hljs-params">(self, pHead)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pHead:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
         
        dummy = pHead
         
        <span class="hljs-comment"># first step, N' to N next</span>
        <span class="hljs-keyword">while</span> dummy:
            dummynext = dummy.next
            copynode = RandomListNode(dummy.label)		<span class="hljs-comment">#复制值</span>
            copynode.next = dummynext			<span class="hljs-comment">#让N'指向原来N的下一个</span>
            dummy.next = copynode				<span class="hljs-comment">#让N指向N'</span>
            dummy = dummynext					<span class="hljs-comment">#指针后移</span>
         
        dummy = pHead
         
        <span class="hljs-comment"># second step, random' to random'</span>
        <span class="hljs-keyword">while</span> dummy:
            dummyrandom = dummy.random
            copynode = dummy.next			
            <span class="hljs-keyword">if</span> dummyrandom:
                copynode.random = dummyrandom.next
            dummy = copynode.next
         
        <span class="hljs-comment"># third step, split linked list</span>
        dummy = pHead
        copyHead = pHead.next
        <span class="hljs-keyword">while</span> dummy:
            copyNode = dummy.next
            dummynext = copyNode.next
            dummy.next = dummynext
            <span class="hljs-keyword">if</span> dummynext:
                copyNode.next = dummynext.next
            <span class="hljs-keyword">else</span>:
                copyNode.next = <span class="hljs-literal">None</span>
            dummy = dummynext
 
        <span class="hljs-keyword">return</span> copyHead</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2019/12/08/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="一、linux常用命令"><a href="#一、linux常用命令" class="headerlink" title="一、linux常用命令"></a>一、linux常用命令</h4><ol>
<li><h5 id="find-基本语法"><a href="#find-基本语法" class="headerlink" title="find 基本语法"></a>find 基本语法</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">find [PATH] [option] [action]
<span class="hljs-meta">
#</span><span class="bash"> 与时间有关的参数：</span>
-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；
-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；
-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；
-newer file : 列出比file还要新的文件名
<span class="hljs-meta">#</span><span class="bash"> 例如：</span>
find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件
<span class="hljs-meta">
#</span><span class="bash"> 与用户或用户组名有关的参数：</span>
-user name : 列出文件所有者为name的文件
-group name : 列出文件所属用户组为name的文件
-uid n : 列出文件所有者为用户ID为n的文件
-gid n : 列出文件所属用户组为用户组ID为n的文件
<span class="hljs-meta">#</span><span class="bash"> 例如：</span>
find /home/hadoop -user hadoop # 在目录/home/hadoop中找出所有者为hadoop的文件
<span class="hljs-meta">
#</span><span class="bash"> 与文件权限及名称有关的参数：</span>
-name filename ：找出文件名为filename的文件
-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件
-tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、
             目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；
-perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；
-perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示
-perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示
<span class="hljs-meta">#</span><span class="bash"> 例如：</span>
find / -name passwd # 查找文件名为passwd的文件
find . -perm 0755 # 查找当前目录中文件权限的0755的文件
find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte</code></pre></div>



<ol start="2">
<li><h5 id="ls-命令，展示文件夹内内容"><a href="#ls-命令，展示文件夹内内容" class="headerlink" title="ls 命令，展示文件夹内内容"></a>ls 命令，展示文件夹内内容</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">-a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～ 
-A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～ 
-d ：仅列出目录本身，而不是列出目录内的档案数据 
-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) 
-F ：根据档案、目录等信息，给予附加数据结构，例如： 
*：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； 
-h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； 
-i ：列出 inode 位置，而非列出档案属性； 
-l ：长数据串行出，包含档案的属性等等数据； 
-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) 
-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； 
-R ：连同子目录内容一起列出来； 
-S ：以档案容量大小排序！ 
-t ：依时间排序 
--color=never ：不要依据档案特性给予颜色显示； 
--color=always ：显示颜色 
--color=auto ：让系统自行依据设定来判断是否给予颜色 
--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 
--time=&#123;atime,ctime&#125; ：输出 access 时间或 改变权限属性时间 (ctime) 
而非内容变更时间 (modification time)</code></pre></div>



<ol start="3">
<li><h5 id="cd-命令："><a href="#cd-命令：" class="headerlink" title="cd 命令："></a>cd 命令：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">cd /root/Docements # 切换到目录/root/Docements
cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录  
cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</code></pre></div>

<ol start="4">
<li><h5 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h5></li>
<li><p>显示树形的层级目录结构，非原生命令，需要安装tree</p>
</li>
<li><h5 id="cp-命令，作用复制："><a href="#cp-命令，作用复制：" class="headerlink" title="cp 命令，作用复制："></a>cp 命令，作用复制：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">-a ：将文件的特性一起复制
-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份
-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行
-r ：递归持续复制，用于目录的复制行为
-u ：目标文件与源文件有差异时才会复制</code></pre></div>

<ol start="6">
<li><h5 id="rm命令作用为删除，参数："><a href="#rm命令作用为删除，参数：" class="headerlink" title="rm命令作用为删除，参数："></a>rm命令作用为删除，参数：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">-f ：就是force的意思，忽略不存在的文件，不会出现警告消息
-i ：互动模式，在删除前会询问用户是否操作
-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</code></pre></div>

<ol start="7">
<li><h5 id="mv命令作用为移动文件："><a href="#mv命令作用为移动文件：" class="headerlink" title="mv命令作用为移动文件："></a>mv命令作用为移动文件：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖
-i ：若目标文件已经存在，就会询问是否覆盖
-u ：若目标文件已经存在，且比目标文件新，才会更新</code></pre></div>

<ol start="8">
<li><h5 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">pwd -P # 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径</code></pre></div>

<ol start="9">
<li><h5 id="tar命令，用于压缩解压："><a href="#tar命令，用于压缩解压：" class="headerlink" title="tar命令，用于压缩解压："></a>tar命令，用于压缩解压：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">-c ：新建打包文件
-t ：查看打包文件的内容含有哪些文件名
-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中
-j ：通过bzip2的支持进行压缩/解压缩
-z ：通过gzip的支持进行压缩/解压缩
-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来
-f filename ：filename为要处理的文件
-C dir ：指定压缩/解压缩的目录dirs</code></pre></div>

<p>缩略版</p>
<div class="hljs"><pre><code class="hljs shell">压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称
查询：tar -jtv -f filename.tar.bz2
解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</code></pre></div>

<ol start="10">
<li><h5 id="mkdir命令创建目录："><a href="#mkdir命令创建目录：" class="headerlink" title="mkdir命令创建目录："></a>mkdir命令创建目录：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">mkdir [选项]... 目录... 
 -m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask
 -p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; 
 -v, --verbose  每次创建新目录都显示信息</code></pre></div>

<ol start="11">
<li><h5 id="rmdir-命令删除目录："><a href="#rmdir-命令删除目录：" class="headerlink" title="rmdir 命令删除目录："></a>rmdir 命令删除目录：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">rmdir [选项]... 目录...
-p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 
-v --verbose  显示指令执行过程</code></pre></div>

<ol start="12">
<li><h5 id="gzip-命令压缩文件或文件夹为-gz文件："><a href="#gzip-命令压缩文件或文件夹为-gz文件：" class="headerlink" title="gzip 命令压缩文件或文件夹为 .gz文件："></a>gzip 命令压缩文件或文件夹为 .gz文件：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell"> gzip[参数][文件或者目录]
-a or --ascii 　使用ASCII文字模式。 
-c or --stdout or --to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 
-d or --decompress or ----uncompress 　解开压缩文件。 
-f or --force 　强行压缩文件。不理会文件名称 or 硬连接是否存在以及该文件是否为符号连接。 
-h or --help 　在线帮助。 
-l or --list 　列出压缩文件的相关信息。 
-L or --license 　显示版本与版权信息。 
-n or --no-name 　压缩文件时，不保存原来的文件名称及时间戳记。 
-N or --name 　压缩文件时，保存原来的文件名称及时间戳记。 
-q or --quiet 　不显示警告信息。 
-r or --recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 
-S&lt;压缩字尾字符串&gt; or ----suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 
-t or --test 　测试压缩文件是否正确无误。 
-v or --verbose 　显示指令执行过程。 
-V or --version 　显示版本信息。 
-num 用指定的数字num调整压缩的速度，-1 or --fast表示最快压缩方法（低压缩比），-9 or --best表示最慢压缩方法（高压缩比）。系统缺省值为6。</code></pre></div>

<h4 id="二-进程相关命令："><a href="#二-进程相关命令：" class="headerlink" title="二. 进程相关命令："></a><strong>二. 进程相关命令：</strong></h4><ol start="13">
<li><h5 id="ps-命令显示运行的进程，"><a href="#ps-命令显示运行的进程，" class="headerlink" title="ps 命令显示运行的进程，"></a>ps 命令显示运行的进程，</h5><p>还会显示进程的一些信息如pid, cpu和内存使用情况等：</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell">-A ：所有的进程均显示出来
-a ：不与terminal有关的所有进程
-u ：有效用户的相关进程
-x ：一般与a参数一起使用，可列出较完整的信息
-l ：较长，较详细地将PID的信息列出</code></pre></div>

<ol start="14">
<li><h5 id="kill-命令用于终止进程，参数："><a href="#kill-命令用于终止进程，参数：" class="headerlink" title="kill 命令用于终止进程，参数："></a>kill 命令用于终止进程，参数：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">kill -signal PID

1：SIGHUP，启动被终止的进程
2：SIGINT，相当于输入ctrl+c，中断一个程序的进行
9：SIGKILL，强制中断一个进程的进行
15：SIGTERM，以正常的结束进程方式来终止进程
17：SIGSTOP，相当于输入ctrl+z，暂停一个进程s的进行</code></pre></div>

<ol start="15">
<li><h5 id="killall-命令和参数："><a href="#killall-命令和参数：" class="headerlink" title="killall 命令和参数："></a>killall 命令和参数：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">skillall [-iIe] [command name]

-i ：交互式的意思，若需要删除时，会询问用户
-e ：表示后面接的command name要一致，但command name不能超过15个字符
-I ：命令名称忽略大小写
<span class="hljs-meta">#</span><span class="bash"> 例如：</span>
killall -SIGHUP syslogd # 重新启动syslogd</code></pre></div>

<ol start="16">
<li><h5 id="crontab命令是启动linux定时任务的服务"><a href="#crontab命令是启动linux定时任务的服务" class="headerlink" title="crontab命令是启动linux定时任务的服务"></a>crontab命令是启动linux定时任务的服务</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">service cron start # 启动cronjob
service cron stop # 停止cronjob
service cron restart #  重启cronjob
crontab -e # 编辑cronjob任务</code></pre></div>

<ol start="17">
<li><h5 id="free-命令"><a href="#free-命令" class="headerlink" title="free 命令"></a>free 命令</h5><p>用于显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer：</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell">free [参数]
-b 　以Byte为单位显示内存使用情况。 
-k 　以KB为单位显示内存使用情况。 
-m 　以MB为单位显示内存使用情况。
-g   以GB为单位显示内存使用情况。 
-o 　不显示缓冲区调节列。 
-s&lt;间隔秒数&gt; 　持续观察内存使用状况。 s
-t 　显示内存总和列。 
-V 　显示版本信息。</code></pre></div>

<ol start="18">
<li><h5 id="top-命令是Linux下常用的性能分析工具"><a href="#top-命令是Linux下常用的性能分析工具" class="headerlink" title="top 命令是Linux下常用的性能分析工具"></a>top 命令是Linux下常用的性能分析工具</h5><p>能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器：</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell">top [参数]
-b 批处理
-c 显示完整的治命令
-I 忽略失效过程
-s 保密模式
-S 累积模式s
-i&lt;时间&gt; 设置间隔时间
-u&lt;用户名&gt; 指定用户名
-p&lt;进程号&gt; 指定进程
-n&lt;次数&gt; 循环显示的次数</code></pre></div>

<h4 id="三-权限相关命令："><a href="#三-权限相关命令：" class="headerlink" title="三. 权限相关命令："></a><strong>三. 权限相关命令：</strong></h4><ol start="19">
<li><h5 id="chmod命令："><a href="#chmod命令：" class="headerlink" title="chmod命令："></a>chmod命令：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">chmod [-R] xyz 文件或目录
-R：进行递归的持续更改，即连同子目录下的所有文件都会更改
<span class="hljs-meta">#</span><span class="bash">同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改，编号是各种权限的数字代码，示例：</span>
chmod 0755 file # 把file的文件权限改变为-rxwr-xr-x
chmod g+w file # 向file的文件权限中加入用户组可写权限</code></pre></div>

<ol start="20">
<li><h5 id="chown命令改变文件所有者："><a href="#chown命令改变文件所有者：" class="headerlink" title="chown命令改变文件所有者："></a>chown命令改变文件所有者：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">chown [para]... [owner][:[group]] file...
  -c 显示更改的部分的信息

　-f 忽略错误信息

　-h 修复符号链接

　-R 处理指定目录以及其子目录下的所有文件

　-v 显示详细的处理信息

　-deference 作用于符号链接的指向，而不是链接文件本身</code></pre></div>

<ol start="21">
<li><h5 id="chgrp命令，改变文件所属组："><a href="#chgrp命令，改变文件所属组：" class="headerlink" title="chgrp命令，改变文件所属组："></a>chgrp命令，改变文件所属组：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">-c 当发生改变时输出调试信息
-f 不显示错误信息
-R 处理指定目录以及其子目录下的所有文件
-v 运行时显示详细的处理信息
--dereference 作用于符号链接的指向，而不是符号链接本身
--no-dereference 作用于符号链接本身</code></pre></div>

<ol start="22">
<li><h5 id="useradd-命令建立用户账号："><a href="#useradd-命令建立用户账号：" class="headerlink" title="useradd 命令建立用户账号："></a>useradd 命令建立用户账号：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ][-u ][用户帐号] 

    -c #&lt;备注&gt; 　加上备注文字。备注文字会保存在passwd的备注栏位中。　
　　-d #&lt;登入目录&gt; 　指定用户登入时的启始目录。
　　-D #　变更预设值．
　　-e # &lt;有效期限&gt; 　指定帐号的有效期限。
　　-f # &lt;缓冲天数&gt; 　指定在密码过期后多少天即关闭该帐号。
　　-g # &lt;群组&gt; 　指定用户所属的群组。
　　-G # &lt;群组&gt; 　指定用户所属的附加群组。
　　-m # 自动建立用户的登入目录。
　　-M # 不要自动建立用户的登入目录。
　　-n # 取消建立以用户名称为名的群组．
　　-r # 建立系统帐号。
　　-s # 指定用户登入后所使用的shell。
　　-u # 指定用户ID。</code></pre></div>

<ol start="23">
<li><h5 id="usermod-修改用户信息："><a href="#usermod-修改用户信息：" class="headerlink" title="usermod 修改用户信息："></a>usermod 修改用户信息：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">usermod -h
usermod [options] LOGIN
 -c #后面接账号的说明，即/etc/passwd第五栏的说明栏，可以加入一些账号的说明
 -d #后面接账号的家目录，即修改/etc/passwd的第六栏
 -e #后面接日期，格式是YYYY-MM-DD也就是在/etc/shadow内的第八栏
 -f #后面接天数，修改shadow的第七栏
 -g #后面接主群组，修改/etc/passwd的第四个字段，即是GID的字段
 -G #后面接附加群组，修改这个使用者能够支持的群组，修改的是/etc/group
 -a #与 -G 合用，可增加附加群组的支持而非设定
 -l #后面接账号名称。修改账号名称，/etc/passwd的第一栏
 -s #后面接Shell的文件，例如/bin/bash或/bin/csh等等
 -u #后面接 UID 数字，修改用户的UID /etc/passwd第三栏
 -L #暂时将用户的密码冻结，让他无法登入。其实就是在/etc/shadow的密码栏前面加上了“!”
 -U #将/etc/shadow 密码栏的“!”去掉</code></pre></div>

<ol start="24">
<li><h5 id="userdel-删除用户："><a href="#userdel-删除用户：" class="headerlink" title="userdel 删除用户："></a>userdel 删除用户：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">userdel [options] LOGIN
-f # 强制删除，包括用户的一切相关内容，这个参数是危险的参数，不建议大家使用。详细说明看MAN
-r # 删除用户的家目录和用户的邮件池</code></pre></div>

<ol start="25">
<li><h5 id="groupadd-命令用于将新组加入系统："><a href="#groupadd-命令用于将新组加入系统：" class="headerlink" title="groupadd　命令用于将新组加入系统："></a>groupadd　命令用于将新组加入系统：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">groupadd [－g gid] [－o]] [－r] [－f] groupname

－g gid：指定组ID号。
－o：允许组ID号，不必惟一。
－r：加入组ID号，低于499系统账号。
－f：加入已经有的组时，发展程序退出。</code></pre></div>

<ol start="26">
<li><h5 id="groupdel-命令删除组："><a href="#groupdel-命令删除组：" class="headerlink" title="groupdel　命令删除组："></a>groupdel　命令删除组：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">＃　用于删除不再需要的组，如果指定的组中包含用户，则必须先删除组里面的用户&gt;以后，才能删除组
groupdel [options] GROUP</code></pre></div>

<ol start="27">
<li><h5 id="sudo-用来以其他身份来执行命令，预设的身份为root"><a href="#sudo-用来以其他身份来执行命令，预设的身份为root" class="headerlink" title="sudo 用来以其他身份来执行命令，预设的身份为root:"></a>sudo 用来以其他身份来执行命令，预设的身份为root:</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">sudo(选项)(参数)

-b：在后台执行指令；
-h：显示帮助；
-H：将HOME环境变量设为新身份的HOME环境变量；
-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码；。
-l：列出目前用户可执行与无法执行的指令；
-p：改变询问密码的提示符号；
-s：执行指定的shell；
-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；
-v：延长密码有效期限5分钟；
-V ：显示版本信息。</code></pre></div>

<ol start="28">
<li><h5 id="passwd-设置用户的密码："><a href="#passwd-设置用户的密码：" class="headerlink" title="passwd 设置用户的密码："></a>passwd 设置用户的密码：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">passwd [OPTION...] &lt;accountName&gt;
-k, --keep-tokens       keep non-expired authentication tokens
-d, --delete            delete the password for the named account (root only)
-l, --lock              lock the named account (root only)
-u, --unlock            unlock the named account (root only)
-f, --force             force operation
-x, --maximum=DAYS      maximum password lifetime (root only)
-n, --minimum=DAYS      minimum password lifetime (root only)
-w, --warning=DAYS      number of days warning users receives before password expiration (root only)
-i, --inactive=DAYS     number of days after password expiration when an account becomes disabled (root only)
-S, --status            report password status on the named account (root)</code></pre></div>

<ol start="29">
<li><h5 id="groups-显示用户所属组："><a href="#groups-显示用户所属组：" class="headerlink" title="groups 显示用户所属组："></a>groups 显示用户所属组：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">groups # 默认显示当前用户的组

groups hadoop2 # 显示hadoop2用户的组</code></pre></div>

<h4 id="四-文本查看编辑等命令"><a href="#四-文本查看编辑等命令" class="headerlink" title="四. 文本查看编辑等命令"></a><strong>四. 文本查看编辑等命令</strong></h4><ol start="30">
<li><h5 id="vi-vim-是使用vi编辑器的命令："><a href="#vi-vim-是使用vi编辑器的命令：" class="headerlink" title="vi/vim 是使用vi编辑器的命令："></a>vi/vim 是使用vi编辑器的命令：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">vi /var/log/aa.log # 打开 /var/log/aa.log文件并编辑</code></pre></div>

<ol start="31">
<li><h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h5><p>用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 </p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell"> cat [选项] [文件]...
-A, --show-all           等价于 -vET
-b, --number-nonblank    对非空输出行编号
-e                       等价于 -vE
-E, --show-ends          在每行结束处显示 $
-n, --number     对输出的所有行编号,由1开始对所有输出的行数编号
-s, --squeeze-blank  有连续两行以上的空白行，就代换为一行的空白行 
-t                       与 -vT 等价
-T, --show-tabs          将跳格字符显示为 ^I
-u                       (被忽略)
-v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外</code></pre></div>

<ol start="32">
<li><h5 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h5><p>和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能：</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell">more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] 
命令参数：
+n 从笫n行开始显示
-n 定义屏幕大小为n行
+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 
-c 从顶部清屏，然后显示
-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能
-l 忽略Ctrl+l（换页）字符
-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似
-s 把连续的多个空行显示为一行
-u 把文件内容中的下画线去掉
常用操作命令：
Enter 向下n行，需要定义。默认为1行
Ctrl+F 向下滚动一屏
空格键 向下滚动一屏
Ctrl+B 返回上一屏
= 输出当前行的行号
：f 输出文件名和当前行的行号
V 调用vi编辑器
!命令 调用Shell，并执行命令 
q 退出more</code></pre></div>

<ol start="33">
<li><h5 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h5><p>用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell"> less [参数]  文件 
-b &lt;缓冲区大小&gt; 设置缓冲区的大小
-e 当文件显示结束后，自动离开
-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件
-g 只标志最后搜索的关键词
-i 忽略搜索时的大小写
-m 显示类似more命令的百分比
-N 显示每行的行号
-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来
-Q 不使用警告音
-s 显示连续空行为一行
-S 行过长时间将超出部分舍弃
-x &lt;数字&gt; 将“tab”键显示为规定的数字空格
/字符串：向下搜索“字符串”的功能
?字符串：向上搜索“字符串”的功能
n：重复前一个搜索（与 / 或 ? 有关）
N：反向重复前一个搜索（与 / 或 ? 有关）
b 向后翻一页
d 向后翻半页
h 显示帮助界面
Q 退出less 命令
u 向前滚动半页
y 向前滚动一行
空格键 滚动一行
回车键 滚动一页
[pagedown]： 向下翻动一页
[pageup]： 向上翻动一页</code></pre></div>

<ol start="34">
<li><h5 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. </span>
tail[必要参数][选择参数][文件]   

-f 循环读取
-q 不显示处理信息
-v 显示详细的处理信息
-c&lt;数目&gt; 显示的字节数
-n&lt;行数&gt; 显示行数
--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. 
-q, --quiet, --silent 从不输出给出文件名的首部 
-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</code></pre></div>

<ol start="35">
<li><h5 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h5><p>用于显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行：</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell">head [参数]... [文件]...  
-q 隐藏文件名
-v 显示文件名
-c&lt;字节&gt; 显示字节数
-n&lt;行数&gt; 显示的行数</code></pre></div>

<ol start="36">
<li><h5 id="diff-命令"><a href="#diff-命令" class="headerlink" title="diff 命令"></a>diff 命令</h5><p>用于比较两个文件或目录的不同：</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell"> diff[参数][文件1或目录1][文件2或目录2]
<span class="hljs-meta">
#</span><span class="bash"> diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的</span>
<span class="hljs-meta">#</span><span class="bash"> 文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。</span>

-a or --text 　#diff预设只会逐行比较文本文件。
-b or --ignore-space-change 　#不检查空格字符的不同。
-B or --ignore-blank-lines 　#不检查空白行。
-c 　#显示全部内文，并标出不同之处。
-C or --context 　#与执行"-c-"指令相同。
-d or --minimal 　#使用不同的演算法，以较小的单位来做比较。
-D or ifdef 　#此参数的输出格式可用于前置处理器巨集。
-e or --ed 　#此参数的输出格式可用于ed的script文件。
-f or -forward-ed 　#输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。
-H or --speed-large-files 　#比较大文件时，可加快速度。
-l or --ignore-matching-lines 　#若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符 or 字符串，则不显示这两个文件的差异。
-i or --ignore-case 　#不检查大小写的不同。
-l or --paginate 　#将结果交由pr程序来分页。
-n or --rcs 　#将比较结果以RCS的格式来显示。
-N or --new-file 　#在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。
-p 　#若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。
-P or --unidirectional-new-file 　#与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。
-q or --brief 　#仅显示有无差异，不显示详细的信息。
-r or --recursive 　#比较子目录中的文件。
-s or --report-identical-files 　#若没有发现任何差异，仍然显示信息。
-S or --starting-file 　#在比较目录时，从指定的文件开始比较。
-t or --expand-tabs 　#在输出时，将tab字符展开。
-T or --initial-tab 　#在每行前面加上tab字符以便对齐。
-u,-U or --unified= 　#以合并的方式来显示文件内容的不同。
-v or --version 　#显示版本信息。
-w or --ignore-all-space 　#忽略全部的空格字符。
-W or --width 　#在使用-y参数时，指定栏宽。s
-x or --exclude 　#不比较选项中所指定的文件 or 目录。
-X or --exclude-from 　#您可以将文件 or 目录类型存成文本文件，然后在=中指定此文本文件。
-y or --side-by-side 　#以并列的方式显示文件的异同之处。</code></pre></div>

<h4 id="五、网络相关命令："><a href="#五、网络相关命令：" class="headerlink" title="五、网络相关命令："></a><strong>五、网络相关命令：</strong></h4><ol start="37">
<li><h5 id="ping-用于确定主机与外部连接状态："><a href="#ping-用于确定主机与外部连接状态：" class="headerlink" title="ping 用于确定主机与外部连接状态："></a>ping 用于确定主机与外部连接状态：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">ping [参数] [主机名或IP地址]
-d 使用Socket的SO_DEBUG功能。
-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。
-n 只输出数值。
-q 不显示任何传送封包的信息，只显示最后的结果。
-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。
-R 记录路由过程。
-v 详细显示指令的执行过程。
&lt;p&gt;-c 数目：在发送指定数目的包后停止。
-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。
-I 网络界面：使用指定的网络界面送出数据包。
-l 前置载入：设置在送出要求信息之前，先行发出的数据包。
-p 范本样式：设置填满数据包的范本样式。
-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。
-t 存活数值：设置存活数值TTL的大小。</code></pre></div>

<ol start="38">
<li><h5 id="ssh-命令用于远程登录上Linux主机："><a href="#ssh-命令用于远程登录上Linux主机：" class="headerlink" title="ssh 命令用于远程登录上Linux主机："></a>ssh 命令用于远程登录上Linux主机：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">ssh [-l login_name] [-p port] [user@]hostname</code></pre></div>

<ol start="39">
<li><h5 id="scp-命令"><a href="#scp-命令" class="headerlink" title="scp 命令"></a>scp 命令</h5><p>是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的：</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell">scp [参数] [原路径] [目标路径]

-1 强制scp命令使用协议ssh1 
-2 强制scp命令使用协议ssh2 
-4 强制scp命令只使用IPv4寻址 
-6 强制scp命令只使用IPv6寻址 
-B 使用批处理模式（传输过程中不询问传输口令或短语） 
-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） 
-p 保留原文件的修改时间，访问时间和访问权限。 
-q 不显示传输进度条。 
-r 递归复制整个目录。 
-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 
-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 
-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 
-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 
-l limit 限定用户所能使用的带宽，以Kbit/s为单位。 
-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， 
-P port 注意是大写的P, port是指定数据传输用到的端口号 
-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</code></pre></div>

<ol start="40">
<li><h5 id="telnet-命令用来远程登录操作："><a href="#telnet-命令用来远程登录操作：" class="headerlink" title="telnet 命令用来远程登录操作："></a>telnet 命令用来远程登录操作：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell"> telnet[参数][主机]

-8 允许使用8位字符资料，包括输入与输出。
-a 尝试自动登入远端系统。
-b&lt;主机别名&gt; 使用别名指定远端主机名称。
-c 不读取用户专属目录里的.telnetrc文件。
-d 启动排错模式。
-e&lt;脱离字符&gt; 设置脱离字符。
-E 滤除脱离字符。
-f 此参数的效果和指定"-F"参数相同。
-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。
-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。
-K 不自动登入远端主机。
-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。
-L 允许输出8位字符资料。
-n&lt;记录文件&gt; 指定文件记录相关信息。
-r 使用类似rlogin指令的用户界面。
-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。
-x 假设主机有支持数据加密的功能，就使用它。
-X&lt;认证形态&gt; 关闭指定的认证形态。</code></pre></div>

<ol start="41">
<li><h5 id="wget-是从远程下载的工具："><a href="#wget-是从远程下载的工具：" class="headerlink" title="wget 是从远程下载的工具："></a>wget 是从远程下载的工具：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">wget [参数] [URL地址]

启动参数：
-V, –version 显示wget的版本后退出
-h, –help 打印语法帮助
-b, –background 启动后转入后台执行
-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc

记录和输入文件参数：
-o, –output-file=FILE 把记录写到FILE文件中
-a, –append-output=FILE 把记录追加到FILE文件中
-d, –debug 打印调试输出
-q, –quiet 安静模式(没有输出)
-v, –verbose 冗长模式(这是缺省设置)
-nv, –non-verbose 关掉冗长模式，但不是安静模式
-i, –input-file=FILE 下载在FILE文件中出现的URLs
-F, –force-html 把输入文件当作HTML格式文件对待
-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀
–sslcertfile=FILE 可选客户端证书
–sslcertkey=KEYFILE 可选客户端证书的KEYFILE
–egd-file=FILE 指定EGD socket的文件名

下载参数：
–bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)
-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).
-O –output-document=FILE 把文档写到FILE文件中
-nc, –no-clobber 不要覆盖存在的文件或使用.#前缀
-c, –continue 接着下载没下载完的文件
–progress=TYPE 设定进程条标记
-N, –timestamping 不要重新下载文件除非比本地文件新
-S, –server-response 打印服务器的回应
–spider 不下载任何东西
-T, –timeout=SECONDS 设定响应超时的秒数
-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒
–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒
–random-wait 在下载之间等待0…2*WAIT秒
-Y, –proxy=on/off 打开或关闭代理
-Q, –quota=NUMBER 设置下载的容量限制
–limit-rate=RATE 限定下载输率

目录参数：
-nd –no-directories 不创建目录
-x, –force-directories 强制创建目录
-nH, –no-host-directories 不创建主机目录
-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…
–cut-dirs=NUMBER 忽略 NUMBER层远程目录

HTTP 选项参数：
–http-user=USER 设定HTTP用户名为 USER.
–http-passwd=PASS 设定http密码为 PASS
-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)
-E, –html-extension 将所有text/html文档以.html扩展名保存
–ignore-length 忽略 `Content-Length’头域
–header=STRING 在headers中插入字符串 STRING
–proxy-user=USER 设定代理的用户名为 USER
–proxy-passwd=PASS 设定代理的密码为 PASS
–referer=URL 在HTTP请求中包含 `Referer: URL’头
-s, –save-headers 保存HTTP头到文件
-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION
–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)
–cookies=off 不使用 cookies
–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie
–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中

FTP 选项参数：
-nr, –dont-remove-listing 不移走 `.listing’文件
-g, –glob=on/off 打开或关闭文件名的 globbing机制
–passive-ftp 使用被动传输模式 (缺省值).
–active-ftp 使用主动传输模式
–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)

递归下载参数：
-r, –recursive 递归下载－－慎用!
-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)
–delete-after 在现在完毕后局部删除文件
-k, –convert-links 转换非相对链接为相对链接
-K, –backup-converted 在转换文件X之前，将之备份为 X.orig
-m, –mirror 等价于 -r -N -l inf -nr
-p, –page-requisites 下载显示HTML文件的所有图片

递归下载中的包含和不包含(accept/reject)：
-A, –accept=LIST 分号分隔的被接受扩展名的列表
-R, –reject=LIST 分号分隔的不被接受的扩展名的列表
-D, –domains=LIST 分号分隔的被接受域的列表
–exclude-domains=LIST 分号分隔的不被接受的域的列表
–follow-ftp 跟踪HTML文档中的FTP链接
–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表
-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表
-H, –span-hosts 当递归时转到外部主机
-L, –relative 仅仅跟踪相对链接
-I, –include-directories=LIST 允许目录的列表
-X, –exclude-directories=LIST 不被包含目录的列表
-np, –no-parent 不要追溯到父目录
wget -S –spider url 不下载只显示过程</code></pre></div>

<ol start="42">
<li><h5 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h5><p>用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置：</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell"> ifconfig [网络设备] [参数]

up 启动指定网络设备/网卡。
down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。
arp 设置指定网卡是否支持ARP协议。
-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包
-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包
-a 显示全部接口信息
-s 显示摘要信息（类似于 netstat -i）
add 给指定网卡配置IPv6地址
del 删除指定网卡的IPv6地址
&lt;硬件地址&gt; 配置网卡最大的传输单元
mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)
netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。
tunel 建立隧道
dstaddr 设定一个远端地址，建立点对点通信
-broadcast&lt;地址&gt; 为指定网卡设置广播协议
-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议
multicast 为网卡设置组播标志
address 为网卡设置IPv4地址
txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度</code></pre></div>

<ol start="43">
<li><h5 id="route命令"><a href="#route命令" class="headerlink" title="route命令"></a>route命令</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell"> route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 
-c  # 显示更多信息
-n  # 不解析名字
-v  # 显示详细的处理信息
-F  # 显示发送信息
-C # 显示路由缓存
-f  # 清除所有网关入口的路由表。 
-p # 与 add 命令一起使用时使路由具有永久性。</code></pre></div>

<h4 id="六、-搜索文件："><a href="#六、-搜索文件：" class="headerlink" title="六、 搜索文件："></a><strong>六、 搜索文件：</strong></h4><ol start="44">
<li><h5 id="whereis-命令："><a href="#whereis-命令：" class="headerlink" title="whereis 命令："></a>whereis 命令：</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和locate时，会从数据库中查找数据，而不是像find命令那样，通过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 </span>

 whereis [-bmsu] [BMS 目录名 -f ] 文件名
 -b 定位可执行文件。
　-m 定位帮助文件。
　-s 定位源代码文件。
　-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。
　-B 指定搜索可执行文件的路径。
　-M 指定搜索帮助文件的路径。
　-S 指定搜索源代码文件的路径。</code></pre></div>

<ol start="45">
<li><h5 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h5></li>
</ol>
<div class="hljs"><pre><code class="hljs shell">＃　locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)

Locate [选择参数] [样式]
-e   将排除在寻找的范围之外。
-1  如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。
-f   将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。
-q  安静模式，不会显示任何错误讯息。
-n 至多显示 n个输出。
-r 使用正规运算式 做寻找的条件。
-o 指定资料库存的名称。
-d 指定资料库的路径
-h 显示辅助讯息
-V 显示程式的版本讯息</code></pre></div>

<ol start="46">
<li><h5 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h5><p>在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果：</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell">which 可执行文件名称 
-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
-p 　与-n参数相同，但此处的包括了文件的路径。
-w 　指定输出时栏位的宽度。
-V 　显示版本信息</code></pre></div>

<p><strong>七、 其他：</strong></p>
<ol start="47">
<li><h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5></li>
</ol>
<p>该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，比如可以加在ps, tail, cat后面</p>
<p>它的简单语法为</p>
<div class="hljs"><pre><code class="hljs shell">grep [-acinv] [--color=auto] '查找字符串' filename</code></pre></div>

<ol start="48">
<li><h5 id="clear-命令"><a href="#clear-命令" class="headerlink" title="clear 命令"></a>clear 命令</h5><p>用于清除终端屏幕上现有的文字内容</p>
</li>
<li><h5 id="date-命令"><a href="#date-命令" class="headerlink" title="date 命令"></a>date 命令</h5><p>用于显示或设定时间：</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell">date [参数]... [+格式]

必要参数:
<span class="hljs-meta">%</span><span class="bash">H 小时(以00-23来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">I 小时(以01-12来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">K 小时(以0-23来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">l 小时(以0-12来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">M 分钟(以00-59来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">P AM或PM。 </span>
<span class="hljs-meta">%</span><span class="bash">r 时间(含时分秒，小时以12小时AM/PM来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">s 总秒数。起算时间为1970-01-01 00:00:00 UTC。 </span>
<span class="hljs-meta">%</span><span class="bash">S 秒(以本地的惯用法来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">T 时间(含时分秒，小时以24小时制来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">X 时间(以本地的惯用法来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">Z 市区。 </span>
<span class="hljs-meta">%</span><span class="bash">a 星期的缩写。 </span>
<span class="hljs-meta">%</span><span class="bash">A 星期的完整名称。 </span>
<span class="hljs-meta">
%</span><span class="bash">b 月份英文名的缩写。 </span>
<span class="hljs-meta">%</span><span class="bash">B 月份的完整英文名称。 </span>
<span class="hljs-meta">%</span><span class="bash">c 日期与时间。只输入date指令也会显示同样的结果。 </span>
<span class="hljs-meta">%</span><span class="bash">d 日期(以01-31来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">D 日期(含年月日)。 </span>
<span class="hljs-meta">%</span><span class="bash">j 该年中的第几天。 </span>
<span class="hljs-meta">%</span><span class="bash">m 月份(以01-12来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">U 该年中的周数。 </span>
<span class="hljs-meta">%</span><span class="bash">w 该周的天数，0代表周日，1代表周一，异词类推。 </span>
<span class="hljs-meta">%</span><span class="bash">x 日期(以本地的惯用法来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">y 年份(以00-99来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">Y 年份(以四位数来表示)。 </span>
<span class="hljs-meta">%</span><span class="bash">n 在显示时，插入新的一行。 </span>
<span class="hljs-meta">%</span><span class="bash">t 在显示时，插入tab。 </span>
MM 月份(必要) 
DD 日期(必要) 
hh 小时(必要) 
mm 分钟(必要)
ss 秒(选择性) 

选择参数:
-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。 
-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。 
-u 　显示GMT。</code></pre></div>

<ol start="50">
<li><h5 id="ln-命令"><a href="#ln-命令" class="headerlink" title="ln 命令"></a>ln 命令</h5><p>为某一个文件在另外一个位置建立一个同步的链接</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs shell">Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。

软链接：
1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
2.软链接可以 跨文件系统 ，硬链接不可以
3.软链接可以对一个不存在的文件名进行链接
4.软链接可以对目录进行链接

硬链接:
1.硬链接，以文件副本的形式存在。但不占用实际空间。
2.不允许给目录创建硬链接
3.硬链接只有在同一个文件系统中才能创建

ln [参数][源文件或目录][目标文件或目录]

必要参数:
-b 删除，覆盖以前建立的链接
-d 允许超级用户制作目录的硬链接
-f 强制执行
-i 交互模式，文件存在则提示用户是否覆盖
-n 把符号链接视为一般目录
-s 软链接(符号链接)
-v 显示详细的处理过程

选择参数:
-S “-S&lt;字尾备份字符串&gt; ”或 “--suffix=&lt;字尾备份字符串&gt;”
-V “-V&lt;备份方式&gt;”或“--version-control=&lt;备份方式&gt;”</code></pre></div>

]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql基本命令</title>
    <url>/2019/12/07/Mysql%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="一、MySQL基本命令"><a href="#一、MySQL基本命令" class="headerlink" title="一、MySQL基本命令"></a>一、MySQL基本命令</h4><p>登录数据库</p>
<div class="hljs"><pre><code class="hljs mysql">mysql -u root -p</code></pre></div>

<p>修改密码</p>
<div class="hljs"><pre><code class="hljs mysql">mysqladmin -u用户名 -p旧密码 password 新密码</code></pre></div>



<h4 id="二、MySQL–常用命令"><a href="#二、MySQL–常用命令" class="headerlink" title="二、MySQL–常用命令"></a>二、MySQL–常用命令</h4><h5 id="1、创建数据库（Create）"><a href="#1、创建数据库（Create）" class="headerlink" title="1、创建数据库（Create）"></a>1、创建数据库（Create）</h5><div class="hljs"><pre><code class="hljs mysql">create database db_name;  -- 创建数据库
show databases;           -- 显示所有的数据库
drop database db_name;    -- 删除数据库
use db_name;              -- 选择数据库
create table tb_name (字段名 varchar(20), 字段名 char(1));   -- 创建数据表模板
show tables;              -- 显示数据表
desc tb_name；            -- 显示表结构
drop table tb_name；      -- 删除表
    
例如：

&#x2F;*创建学生表*&#x2F;
create table Student(
     Sno char(10) primary key,
     Sname char(20) unique,
     Ssex char(2),
     Sage smallint,
     Sdept char(20)
)；</code></pre></div>

<h5 id="2、插入数据（Insert）"><a href="#2、插入数据（Insert）" class="headerlink" title="2、插入数据（Insert）"></a>2、插入数据（Insert）</h5><div class="hljs"><pre><code class="hljs mysql">&#x2F;*第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：*&#x2F;
insert into tb_name values (value1,value2,value3,...);
&#x2F;*第二种形式需要指定列名及被插入的值：*&#x2F;
insert into tb_name (column1,column2,column3,...) values (value1,value2,value3,...);</code></pre></div>

<p>例如：</p>
<div class="hljs"><pre><code class="hljs mysql">&#x2F;*插入数据*&#x2F;

insert into Student values ( 20180001,张三,男,20,CS）;

insert into Student values ( 20180002,李四,男,19,CS）;

insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20191124,王五,男,18,MA）;

insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20191123,赵六,男,20,IS）;</code></pre></div>



<h5 id="3、查询数据-Select"><a href="#3、查询数据-Select" class="headerlink" title="3、查询数据(Select)"></a>3、查询数据(Select)</h5><p>基本select语句：<br>      一个基本的select语句可分解成三个部分：查找什么数据（select）、从哪里查找（from）、查找的条件是什么（where）。</p>
<div class="hljs"><pre><code class="hljs mysql">select 语句的一般格式如下：
               select &lt;目标列表达式列表&gt;
               [into 新表名]
               from 表名或视图名
               [where &lt;条件&gt;]
               [group by &lt;分组表达式&gt;]
               [having &lt;条件&gt;]
               [order by &lt;排序表达式&gt;[ASC|DESC]]</code></pre></div>



<h6 id="一-查询指定的列"><a href="#一-查询指定的列" class="headerlink" title="(一)查询指定的列"></a>(一)查询指定的列</h6><p> 1⃣️查询表中所有列<br>在select语句指定列的位置上使用*号时，表示查询表的所有列。</p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_name；</code></pre></div>

<p>2⃣️查询表中指定的列<br>查询多列时，列名之间要用逗号隔开。</p>
<div class="hljs"><pre><code class="hljs mysql">select tb_name.&lt;字符型字段&gt;,&lt;字符型字段&gt; ... from  tb_name;</code></pre></div>

<p>3⃣️指定查询结果中的列标题<br>通过指定列标题（也叫列别名）可使输出结果更容易被人理解。<br>指定列标题时，可在列名之后使用AS子句；也可使用:列别名=&lt;表达式&gt;的形式指定列标题。<br>              AS子句的格式为：列名或计算表达式 [AS] 列标题</p>
<div class="hljs"><pre><code class="hljs mysql">select &lt;字符型字段&gt; as 列标题1,&lt;字符型字段&gt; as 列标题2, &lt;字符型字段&gt; as 列标题3 from bt_name；</code></pre></div>

<p> 4⃣️查询经过计算的列（即表达式的值）<br> 使用select对列进行查询时，不仅可以直接以列的原始值作为结果，而且还可以将列值进行计算后所得值作为查询结果，即select子句可以查询表达式的值,表达式可由列名、常量及算术运算符组成。<br>              查询结果计算列显示“无列名”,一般要给计算列加列标题。<br>              其中：表达式中可以使用的运算符有：加+、减-、乘*、除/、取余%</p>
<div class="hljs"><pre><code class="hljs mysql">select &lt;字符型字段&gt;,&lt;字符型字段&gt;,列标题 &#x3D; &lt;字符型字段&gt; * n from tb_name；</code></pre></div>







<h6 id="二-选择行：选择表中的部分行或全部行作为查询的结果"><a href="#二-选择行：选择表中的部分行或全部行作为查询的结果" class="headerlink" title="(二)选择行：选择表中的部分行或全部行作为查询的结果"></a>(二)选择行：选择表中的部分行或全部行作为查询的结果</h6><p>​       </p>
<div class="hljs"><pre><code class="hljs mysql">select [all|distinct] [top n[percent]]&lt;目标列表达式列表&gt; from 表名</code></pre></div>

<p>​    1⃣️消除查询结果中的重复行<br>​    对于关系数据库来说，表中的每一行都必须是不同的(即无重复行)。但当对表进行查询时若只选择其中的某些列，查询结果中就可能会出现重复行。<br>在select语句中使用distinct关键字可以消除结果集中的重复行,</p>
<div class="hljs"><pre><code class="hljs mysql">select distinct &lt;字符型字段&gt;[,&lt;字符型字段&gt;,...] from tb_name；</code></pre></div>

<p>​    2⃣️限制查询结果中的返回行数<br>  使用top选项可限制查询结果的返回行数，即返回指定个数的记录数。<br>  其中：n是一个正整数，表示返回查询结果集的前n行；若带percent关键字，则表示返回结果集的前n%行。<br>​              </p>
<div class="hljs"><pre><code class="hljs mysql">select  top n from tb_name; &#x2F;*查询前 n 的数据*&#x2F;
select top n percent from tb_name; &#x2F;*查询前 n% tb_name的数据*&#x2F;</code></pre></div>





<h6 id="三-查询满足条件的行-用where子句实现条件查询"><a href="#三-查询满足条件的行-用where子句实现条件查询" class="headerlink" title="(三)查询满足条件的行: 用where子句实现条件查询"></a>(三)查询满足条件的行: 用where子句实现条件查询</h6><p>​            通过where子句实现,该子句必须紧跟在From子句之后。<br>​            格式为：</p>
<div class="hljs"><pre><code class="hljs mysql">select [all|distinct] [top n[percent]]&lt;目标列表达式列表&gt; from 表名 where &lt;条件&gt;；</code></pre></div>

<p>​            说明：在查询条件中可使用以下运算符或表达式：<br>​                  运算符                 运算符标识<br>​                  比较运算符         &lt;=，&lt;，=，&gt;，&gt;=，!=，&lt;&gt;，!&gt;，!&lt;<br>​                  范围运算符         between… and，not between… and<br>​                  列举运算符         in，not in<br>​                  模糊匹配运算符 like，not like<br>​                  空值运算符         is null，is not null<br>​                  逻辑运算符         and，or，not<br>​        1.使用比较运算符：</p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_name where &lt;字符型字段&gt; &gt;&#x3D; n ；</code></pre></div>

<p>​        2.指定范围：<br>​              用于指定范围的关键字有两个：between…and和 not between…and。</p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_name where [not] between &lt;表达式1&gt; and &lt;表达式2&gt;;</code></pre></div>

<p>​              其中：between关键字之后的是范围的下限（即低值）,and关键字之后的是范围的上限（即高值）<br>​              用于查找字段值在（或不在）指定范围的行。<br>​       3.使用列举:<br>​             使用in关键字可以指定一个值的集合，集合中列出所有可能的值，当表达式的值与集合中的任一元素个匹配时，即返回true，否则返回false。</p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_name where &lt;字符型字段&gt; [not] in(值1,值2,...,值n);</code></pre></div>

<p>​       4.使用通配符进行模糊查询:<br>​             可用like 子句进行字符串的模糊匹配查询，like子句将返回逻辑值（true或False）</p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_name where &lt;字符型字段&gt; [not] like &lt;匹配串&gt;；</code></pre></div>

<p>​             其含义是：查找指定字段值与匹配串相匹配的记录。匹配串中通常含有通配符%和_（下划线）。<br>​             其中:  %：代表任意长度（包括0）的字符串<br>​       5.使用null的查询<br>​             当需要判定一个表达式的值是否为空值时，使用 is null关键字。<br>​             当不使用not时，若表达式的值为空值，则返回true，否则返回false；当使用not时，结果刚好相反。</p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_name where &lt;字符型字段&gt; is [not] null;</code></pre></div>

<p>​        6.多重条件查询：使用逻辑运算符<br>​             逻辑运算符and（与：两个条件都要满足）和or（或：满足其中一个条件即可）可用来联接多个查询条件。and的优先级高于or,但若使用括号可以改变优先级。</p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_name where &lt;字符型字段&gt; &#x3D; &#39;volues&#39; and &lt;字符型字段&gt; &gt; n;</code></pre></div>







<h6 id="四-对查询结果排序"><a href="#四-对查询结果排序" class="headerlink" title="(四)对查询结果排序"></a>(四)对查询结果排序</h6><p>​        order by子句可用于对查询结果按照一个或多个字段的值（或表达式的值）进行升序（ASC）或降序（DESC）排列，默认为升序。<br>​       </p>
<div class="hljs"><pre><code class="hljs mysql">order by &#123;排序表达式[ASC|DESC]&#125;[,...n]；</code></pre></div>

<p>​        其中：排序表达式既可以是单个的一个字段，也可以是由字段、函数、常量等组成的表达式，或一个正整数。<br>​      </p>
<div class="hljs"><pre><code class="hljs mysql">select * from tb_name order by &lt;排序表达式&gt; &lt;排序方法&gt;；</code></pre></div>







<h6 id="五-使用统计函数-又称集函数，聚合函数"><a href="#五-使用统计函数-又称集函数，聚合函数" class="headerlink" title="(五)使用统计函数:又称集函数，聚合函数"></a>(五)使用统计函数:又称集函数，聚合函数</h6><p>​        在对表进行检索时，经常需要对结果进行计算或统计，T-SQL提供了一些统计函数（也称集函数或聚合函数），用来增强检索功能。统计函数用于计算表中的数据，即利用这些函数对一组数据进行计算，并返回单一的值。<br>​        常用统计函数表<br>​              函数名      功能<br>​              AVG         求平均值<br>​              count        求记录个数，返回int类型整数<br>​              max          求最大值<br>​              min           求最小值<br>​              sum          求和</p>
<div class="hljs"><pre><code>1. SUM和AVG
     功能：求指定的数值型表达式的和或平均值。</code></pre></div><p>​             </p>
<div class="hljs"><pre><code><pre><code class="hljs mysql">select avg(&lt;字符型字段&gt;) as 平均数,sum(&lt;字符型字段&gt;) as 总数 from tb_name where &lt;字符型字段&gt; &#x3D;&#39;字符串&#39;;</code></pre></code></pre></div><p>​<br>​             </p>
<div class="hljs"><pre><code>2. Max和Min
     功能：求指定表达式的最大值或最小值。

     <pre><code class="hljs mysql">select max(&lt;字符型字段&gt;) as 最大值,min(&lt;字符型字段&gt;) as 最小值 from tb_name;</code></pre></code></pre></div><p>​<br>​             </p>
<div class="hljs"><pre><code>3. count
     该函数有两种格式：count(*)和count([all]|[distinct] 字段名），为避免出错，查询记录个数一般使用count(*)，而查询某字段有几种取值用count(distinct 字段名）。
     (1).count(*):
         功能：统计记录总数。

     <pre><code class="hljs mysql">select count(*) as 总数 from tb_name;</code></pre></code></pre></div>

     (2).count([all]|[distinct] 字段名）
         功能：统计指定字段值不为空的记录个数，字段的数据类型可以是text、image、ntext、uniqueidentifier之外的任何类型。

     <div class="hljs"><pre><code class="hljs mysql">select count(&lt;字符型字段&gt;) as 总数 from tb_name;</code></pre></div><h6 id="六-对查询结果分组"><a href="#六-对查询结果分组" class="headerlink" title="(六)对查询结果分组"></a>(六)对查询结果分组</h6><p> group by子句用于将查询结果表按某一列或多列值进行分组，列值相等的为一组，每组统计出一个结果。该子句常与统计函数一起使用进行分组统计。<br>        group by 分组字段[,…n][having &lt;条件表达式&gt;]；<br>        1⃣️在使用group by子句后<br>             select列表中只能包含：group by子句中所指定的分组字段及统计函数。<br>        2⃣️having子句的用法<br>             having子句必须与group by 子句配合使用，用于对分组后的结果进行筛选（筛选条件中常含有统计函数）。</p>
<p>​        3⃣️ 分组查询时不含统计函数的条件<br>​                通常使用where子句；含有统计函数的条件,则只能用having子句。</p>
<div class="hljs"><pre><code class="hljs mysql">select &lt;字符型字段&gt;,count(*) as 列标题 from tb_name where &lt;字符型字段&gt;&#x3D;&#39;字符串&#39; group by &lt;字符型字段&gt;；</code></pre></div>

<p>​        4⃣️修改数据(Update）</p>
<p>​        Update 语句用于修改表中的数据。</p>
<div class="hljs"><pre><code class="hljs mysql">update tb_name set 列名称 &#x3D; 新值 where 列名称 &#x3D; 某值；</code></pre></div>

<p>​        5⃣️删除数据(Delete)</p>
<p>​        删除单行</p>
<div class="hljs"><pre><code class="hljs mysql">delete from tb_name where 列名称 &#x3D; 某值；</code></pre></div>

<div class="hljs"><pre><code>删除所有行
可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：</code></pre></div><div class="hljs"><pre><code class="hljs mysql">delete * from tb_name   
delete from tb_name；</code></pre></div>





<h4 id="三、MySQL-–-alter命令"><a href="#三、MySQL-–-alter命令" class="headerlink" title="三、MySQL – alter命令"></a>三、MySQL – alter命令</h4><p> alter add命令用来增加表的字段。<br> alter add命令格式：alter table 表名 add字段 类型 其他;</p>
<p> 例如，在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为0</p>
<div class="hljs"><pre><code class="hljs mysql">alter table MyClass add passtest int(4) default &#39;0&#39;;</code></pre></div>

<p>添加两个字段  </p>
<div class="hljs"><pre><code class="hljs mysql">mysql&gt; alter table Person add age int,add address varchar(11);</code></pre></div>

<p> 删除两个字段</p>
<div class="hljs"><pre><code class="hljs mysql">alter table Person drop column age,drop column address;</code></pre></div>

<p> 修改字段的注释</p>
<div class="hljs"><pre><code class="hljs mysql">alter table &#96;student&#96; modify column &#96;id&#96; comment &#39;学号&#39;;</code></pre></div>

<p> 1) 加索引</p>
<div class="hljs"><pre><code class="hljs mysql">alter table 表名 add index 索引名 (字段名1[，字段名2 …]);
alter table employee add index emp_name (name);</code></pre></div>

<p> 2) 加主关键字的索引</p>
<div class="hljs"><pre><code class="hljs mysql">alter table 表名 add primary key (字段名);
alter table employee add primary key(id);</code></pre></div>

<p> 3) 加唯一限制条件的索引</p>
<div class="hljs"><pre><code class="hljs mysql">alter table 表名 add unique 索引名 (字段名);
alter table employee add unique emp_name2(cardnumber);</code></pre></div>

<p> 4) 删除某个索引</p>
<div class="hljs"><pre><code class="hljs mysql">alter table 表名 drop index 索引名;
alter table employee drop index emp_name;</code></pre></div>

<p> 5) 增加字段</p>
<div class="hljs"><pre><code class="hljs mysql">ALTER TABLE table_name ADD field_name field_type;</code></pre></div>

<p> 6) 修改原字段名称及类型</p>
<div class="hljs"><pre><code class="hljs mysql">ALTER TABLE table_name CHANGE old_field_name new_field_name field_type;</code></pre></div>

<p> 7) 删除字段</p>
<div class="hljs"><pre><code class="hljs mysql">ALTER TABLE table_name DROP field_name;</code></pre></div>



<h4 id="四、MySQL-–-应用"><a href="#四、MySQL-–-应用" class="headerlink" title="四、MySQL – 应用"></a>四、MySQL – 应用</h4><p>学生-课程数据库<br> 学生表：Student（<strong>Sno</strong>，Sname，Ssex，Sage，Sdept）<br> 课程表：Course（<strong>Cno</strong>，Cname，Cpno，Ccredit）<br> 学生选课表：SC（<strong>Sno</strong>，<strong>Cno</strong>，Grade）<br> 关系的主码加粗表示。各个表中的数据示例如图所示：</p>
{%asset_img mysql.png Mysql %}

<p> 建立一个“学生”表Student：</p>
<div class="hljs"><pre><code class="hljs mysql">create table Student(
  Sno char(9) peimary key, &#x2F;*列级完整性约束条件，Sno是主码*&#x2F;
  Sname char(20) unique, &#x2F;* Sname取唯一值*&#x2F;
  Ssex char(2),
  Sage smallint,
  Sdept char(20)
);</code></pre></div>

<p> 建立一个“课程”表Course：</p>
<div class="hljs"><pre><code class="hljs mysql">create table Course(
  Sno char(4) primary key, &#x2F;*列级完整性约束条件，Cname不能取空值*&#x2F;
  Sname char(40) not null, &#x2F;*Cpno的含义是先修课*&#x2F;
  Cpno char(4)
  Ccredit smallint,
  foreign key (Cpnoo) references Course(Cno) &#x2F;*表级完整性约束条件，Cpno是外码，被参照表是Course，被参照列是Cno</code></pre></div>

<p>建立学生选课表SC：</p>
<div class="hljs"><pre><code class="hljs mysql">create table SC(
  Sno char(9),
  Cno char(4),
  Grade smallint,
  frimary key (Sno,Cno), &#x2F;*主码由两个属性构成，必须作为表级完整性进行定义*&#x2F;
  foreign key (Sno) references Student(Sno), &#x2F;*表级完整性约束条件，Sno是外码，被参照表是Student*&#x2F;
  foreign key (Cno) references Course(Cno)   &#x2F;*表级完整性约束条件，Cno是外码，被参照表是Course *&#x2F;
);</code></pre></div>

]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>面试准备</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络安全</title>
    <url>/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h5 id="两种攻击"><a href="#两种攻击" class="headerlink" title="两种攻击"></a>两种攻击</h5><ul>
<li>主动攻击：中断、篡改和伪造信息</li>
<li>被动攻击：截获</li>
</ul>
<h5 id="对称加密DES"><a href="#对称加密DES" class="headerlink" title="对称加密DES"></a>对称加密DES</h5><p>即加密密钥与解密密钥是使用相同的密码体制，使用64位的密钥</p>
<h5 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h5><p>使用不同的加密密钥和解密密钥</p>
<h5 id="数字签名的三个功能"><a href="#数字签名的三个功能" class="headerlink" title="数字签名的三个功能"></a>数字签名的三个功能</h5><ul>
<li>1⃣️报文鉴别</li>
<li>2⃣️报文的完整性</li>
<li>3⃣️不可否认</li>
</ul>
<h5 id="具有保密性的数字签名过程："><a href="#具有保密性的数字签名过程：" class="headerlink" title="具有保密性的数字签名过程："></a>具有保密性的数字签名过程：</h5><img src="/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/szqm.png" srcset="/img/loading.gif" class title="数字签名过程">



<h5 id="报文鉴别："><a href="#报文鉴别：" class="headerlink" title="报文鉴别："></a>报文鉴别：</h5><ul>
<li>1⃣️密码散列函数</li>
<li>2⃣️MD5和SHA-1</li>
</ul>
<h5 id="实体鉴别：口令（验证码）"><a href="#实体鉴别：口令（验证码）" class="headerlink" title="实体鉴别：口令（验证码）"></a>实体鉴别：口令（验证码）</h5><h5 id="对称密钥分配：KDC密钥分配中心"><a href="#对称密钥分配：KDC密钥分配中心" class="headerlink" title="对称密钥分配：KDC密钥分配中心"></a>对称密钥分配：KDC密钥分配中心</h5><h5 id="非对称密钥分配：CA认证中心"><a href="#非对称密钥分配：CA认证中心" class="headerlink" title="非对称密钥分配：CA认证中心"></a>非对称密钥分配：CA认证中心</h5><h5 id="网络层上的安全协议：IPsec协议族"><a href="#网络层上的安全协议：IPsec协议族" class="headerlink" title="网络层上的安全协议：IPsec协议族"></a>网络层上的安全协议：IPsec协议族</h5><h5 id="运输层上的安全协议："><a href="#运输层上的安全协议：" class="headerlink" title="运输层上的安全协议："></a>运输层上的安全协议：</h5><ul>
<li>安全套接字SSL</li>
<li>运输层安全TLS</li>
</ul>
<h5 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h5><ul>
<li>分组过滤路由器</li>
<li>应用网关（代理服务器）</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-应用层</title>
    <url>/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h5 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h5><p>是互联网使用的命名系统，用来把人们使用的机器名字转换为IP地址</p>
<p>一个服务器所负责管辖的范围叫做<strong>区</strong></p>
<p>每一个区设置相应的<strong>权限域名服务器</strong>，用来保存该区中的所有主机的域名到IP地址的映射</p>
<h5 id="四个域名服务器："><a href="#四个域名服务器：" class="headerlink" title="四个域名服务器："></a>四个域名服务器：</h5><ul>
<li>根域名服务器</li>
<li>顶级域名服务器</li>
<li>权限域名服务器</li>
<li>本地域名服务器</li>
</ul>
<h5 id="两种查询"><a href="#两种查询" class="headerlink" title="两种查询"></a>两种查询</h5><ul>
<li>迭代查询：即一个一个地进行查询，都是本地域名服务器发起的</li>
<li>递归查询：本地域名服务器询问一个服务器，该服务器询问另一个，直到查询到再依次返回</li>
</ul>
<h5 id="高速缓存："><a href="#高速缓存：" class="headerlink" title="高速缓存："></a>高速缓存：</h5><p>用来存放最近查询过的域名以及从何处获得域名映射的信息记录</p>
<h5 id="高速缓存的作用："><a href="#高速缓存的作用：" class="headerlink" title="高速缓存的作用："></a>高速缓存的作用：</h5><p>为了提高DNS查询效率，并减轻根域名服务器的负荷和减少互联网上的DNS查询报文数量</p>
<h5 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h5><p>FTP使用客户服务器方式，使用TCP可靠的运输服务，需要建立两个TCP的连接，且是并行的</p>
<p>FTP的服务器进程：一个主进程，负责接收新的请求；若干个从属进程，负责处理单个请求</p>
<p>两个从属进程：控制连接，发送控制进程    数据连接，用于传输文件</p>
<h5 id="各类协议"><a href="#各类协议" class="headerlink" title="各类协议"></a>各类协议</h5><p><strong>TFTP</strong>是使用UDP进行数据传输的</p>
<p><strong>TELNET</strong>，终端仿真协议，也是使用客户服务器方式，采用TCP连接</p>
<p>网络虚拟终端<strong>NVT</strong>即TELNET交互中所用的命令，8位一字节，7位传送数据，1位用作控制命令</p>
<p>万维网：<strong>WWW</strong>是一个分布式的超媒体系统，它是超文本系统的扩产，以客户服务器方式工作</p>
<p>同一资源定位符<strong>URL</strong>，标志分布在整个互联网上的万维网文档</p>
<p>超文本传送协议<strong>HTTP</strong>：实现万维网上的各种链接，面向事务的应用层协议，流水线和非流水线工作方式</p>
<p>超文本标记语言<strong>HTML</strong>，显示页面，跳转链接</p>
<p>邮件发送协议<strong>SMTP</strong></p>
<p>邮件接收协议<strong>POP3</strong>、<strong>IMAP</strong>，其中IMAP是联机协议</p>
<p><strong>MIME</strong>，通用互联网邮件扩产，可发送文本、图像、音频、视频</p>
<p><strong>DHCP</strong>，动态主机配置协议，使用客户服务器方式，提供了即插即用联网机制，需要IP的主机在启动时向DHCP服务器广播发送报文（255.255.255.255），即可成为DHCP客户</p>
<h5 id="各应用协议在层次中的位置"><a href="#各应用协议在层次中的位置" class="headerlink" title="各应用协议在层次中的位置"></a>各应用协议在层次中的位置</h5><img src="/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/yingyong.png" srcset="/img/loading.gif" class title="各协议分布">]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-运输层</title>
    <url>/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h5 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h5><table>
<thead>
<tr>
<th>应用层</th>
</tr>
</thead>
<tbody><tr>
<td>运输层</td>
</tr>
<tr>
<td>网络层</td>
</tr>
<tr>
<td>数据链路层</td>
</tr>
<tr>
<td>物理层</td>
</tr>
</tbody></table>
<p>运输层向它上面的应用层提供通信服务</p>
<h5 id="复用："><a href="#复用：" class="headerlink" title="复用："></a>复用：</h5><p>指发送方不同的应用进程都可以使用同一个运输层协议传输数据</p>
<h5 id="分用："><a href="#分用：" class="headerlink" title="分用："></a>分用：</h5><p>指接收方的运输层在剥去报文的首部后能把这些数据正确交付目的应用进程</p>
<h5 id="网络层、运输层的区别："><a href="#网络层、运输层的区别：" class="headerlink" title="网络层、运输层的区别："></a>网络层、运输层的区别：</h5><p>网络层提供主机间的逻辑通信，运输层提供应用进程间的逻辑通信且运输层还要对报文进行差错检测</p>
<h5 id="TCP、IP、UDP的差别"><a href="#TCP、IP、UDP的差别" class="headerlink" title="TCP、IP、UDP的差别"></a>TCP、IP、UDP的差别</h5><table>
<thead>
<tr>
<th>TCP</th>
<th>IP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>面向连接服务</td>
<td>面向无连接服务</td>
<td>面向无连接服务</td>
</tr>
<tr>
<td>字节流接口、流量控制、拥塞控制、保证可靠性</td>
<td>IP数据报接口、主机与主机的通信协议</td>
<td>不可靠传输、进程与进程的通信协议</td>
</tr>
</tbody></table>
<h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h5><p>端口号只具有<strong>本地意义</strong>，且为16位端口号标志一个端口</p>
<p><strong>熟知端口号</strong>：0～1023</p>
<p><strong>登记端口号</strong>：1024～49151</p>
<h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h5><p>UDP数据报格式有首部和数据两个部分。首部很简单，共8字节</p>
<img src="/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/udp.jpg" srcset="/img/loading.gif" class title="udp">

<ul>
<li>源端口：2字节，源端口号</li>
<li>目的端口：2字节，目的端口号</li>
<li>长度：2字节，UDP用户数据报的总长度，以字节为单位</li>
<li>检验和：2字节，用于校验UDP数据报的字段和包含UDP数据报首部的“伪首部”，其校验方法同IP分组首部中的首部校验和</li>
<li>伪首部：是指在TCP的分段或UDP的数据报格式中，在数据报首部前面增加源IP地址、目的IP地址、IP分组的协议字段、TCP或UDP数据报的总长度等共12字节，所构成的扩展首部结构。<strong>其中伪首部是临时添加的，只用来计算检验和，不会上下传递</strong></li>
</ul>
<p>TCP连接的断点叫<strong>套接字</strong>：IP地址+端口号</p>
<h5 id="停止等待协议："><a href="#停止等待协议：" class="headerlink" title="停止等待协议："></a>停止等待协议：</h5><p>每发送完一个分组就停止发送，等待对方的确认，确认后，发送下一个分组</p>
<h5 id="连续ARQ："><a href="#连续ARQ：" class="headerlink" title="连续ARQ："></a>连续ARQ：</h5><p>一次发送多个分组，而无需等待确认，至最后一个分组确认，即可发送下一次的多个分组</p>
<h5 id="GO-Back-N："><a href="#GO-Back-N：" class="headerlink" title="GO-Back-N："></a>GO-Back-N：</h5><p>丢失第N个分组，则确认第N-1个分组，重发N及其之后的分组</p>
<h5 id="TCP数据报格式："><a href="#TCP数据报格式：" class="headerlink" title="TCP数据报格式："></a>TCP数据报格式：</h5><p>首部前20个字节固定，后4n字节可以根据需要而增加</p>
<img src="/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/tcp-0.png" srcset="/img/loading.gif" class title="tcp数据报">

<table>
<thead>
<tr>
<th>源端口</th>
<th>目的端口</th>
<th>序号</th>
<th>确认号</th>
<th>数据偏移</th>
<th>保留</th>
<th>紧急URG</th>
<th>确认ACK</th>
<th>推送PSH</th>
<th>复位RST</th>
<th>同步SYN</th>
<th>终止FIN</th>
<th>窗口</th>
<th>检验和</th>
<th>紧急指针</th>
<th>选项</th>
</tr>
</thead>
<tbody><tr>
<td>2字节</td>
<td>2字节</td>
<td>4字节</td>
<td>4字节</td>
<td>4</td>
<td>6</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>可变，最长40字节</td>
</tr>
</tbody></table>
<ul>
<li>紧急URG：为1时，代表最高优先级数据，应尽快传送</li>
<li>确认ACK：建立连接后，必须置为1</li>
<li>同步SYN：置为1时，表示一个连接请求</li>
<li>推送PSH：置为1时，应尽快交付接收应用进程</li>
<li>复位RST：置为1时，表明TCP连接有严重差错，必须释放连接</li>
<li>终止FIN：置为1时，表明数据发送完毕，释放连接</li>
</ul>
<h5 id="可靠传输："><a href="#可靠传输：" class="headerlink" title="可靠传输："></a>可靠传输：</h5><ul>
<li><p>1⃣️以字节为单位的滑动窗口（流量控制）</p>
</li>
<li><p>2⃣️停止等待协议、连续ARQ、GO-Back-N（确认机制）</p>
</li>
<li><p>3⃣️窗口机制、主动队列管理AQM（拥塞控制）</p>
</li>
</ul>
<h5 id="TCP／IP"><a href="#TCP／IP" class="headerlink" title="TCP／IP"></a>TCP／IP</h5><p>传输控制协议／网际协议，是指能够在多个不同网络间实现信息传输的<strong>协议族</strong>，里面有FTP、SMTP、TCP、UDP、IP等协议</p>
<h5 id="TCP三次握手："><a href="#TCP三次握手：" class="headerlink" title="TCP三次握手："></a>TCP三次握手：</h5><img src="/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/tcp-1.png" srcset="/img/loading.gif" class title="三次握手">

<ul>
<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=j，并将该数据报发送给Server，Client进入SYN_SENT状态，等待Server确认</li>
<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
<li>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<h5 id="TCP四次挥手："><a href="#TCP四次挥手：" class="headerlink" title="TCP四次挥手："></a>TCP四次挥手：</h5><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。<br>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。<br>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
<img src="/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/tcp-2.png" srcset="/img/loading.gif" class title="四次挥手">

<p>上面是一方主动关闭，另一方被动关闭的情况，</p>
<p>实际中还会出现<strong>同时发起主动关闭</strong>的情况，具体流程如下图：</p>
<img src="/2019/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/tcp-3.png" srcset="/img/loading.gif" class title="四次挥手">



<h5 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h5><p>​    这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_24二叉树中和为某一值的路径</title>
    <url>/2019/12/05/%E5%89%91%E6%8C%87offer-24%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这是一个深度遍历的问题，先定义两个列表，一个列表array存储单个路径，一个列表result_all存储整个可行的路径，直接从根节点开始遍历，然后为空就返回，不然的话，就减去root的值，然后把这个节点添加到array列表，再进行判断左右节点是否为空，同时exceptnumber是否为0，也就是看看是否遍历到了叶子节点，且是否和刚好等于exceptnumbert，是的话就把array添加到result_all列表。然后再进行递归遍历左右节点，因为走到这一步，就是没有找到，所以array要pop一下，回溯，返回到上一层，最后result_all返回。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span>
        self.val = x
        self.left = <span class="hljs-literal">None</span>
        self.right = <span class="hljs-literal">None</span>

<span class="hljs-comment">### 前序遍历，深度优先遍历dfs</span>
result_all = []
array = []
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindPath</span><span class="hljs-params">(root, expectNumber)</span>:</span>
    <span class="hljs-comment"># write code here</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> []
    array.append(root.val)
    expectNumber -= root.val
    <span class="hljs-keyword">if</span> expectNumber == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> root.right:
        result_all.append(array[:]) 			<span class="hljs-comment">#深拷贝</span>
    FindPath(root.left, expectNumber)
    FindPath(root.right, expectNumber)
    array.pop()
    <span class="hljs-keyword">return</span> result_all


root = TreeNode(<span class="hljs-number">10</span>)
root.left = TreeNode(<span class="hljs-number">5</span>)
root.right = TreeNode(<span class="hljs-number">12</span>)
root.left.left = TreeNode(<span class="hljs-number">4</span>)
root.left.right = TreeNode(<span class="hljs-number">7</span>)

print(FindPath(root, <span class="hljs-number">19</span>))</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_23二叉搜索树的后序遍历序列</title>
    <url>/2019/12/05/%E5%89%91%E6%8C%87offer-23%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉搜索树也就是二叉排序树，任意节点的左子树的节点都比该节点小，右子树的节点都比该节点大。</p>
<div class="hljs"><pre><code class="hljs angelscript">    <span class="hljs-number">6</span>	
   / \
  <span class="hljs-number">5</span>   <span class="hljs-number">7</span>
 /     \
<span class="hljs-number">3</span>       <span class="hljs-number">9</span>
 \     /
   <span class="hljs-number">4</span>   <span class="hljs-number">8</span></code></pre></div>

<p>就比如这个二叉排序树，后序遍历为435 897 6，可以看出来，最后一个就是根节点，而前半部分就是左子树，后半部分就是右子树，而且这两个子树也符合后序遍历的规则。</p>
<p>也就是采用分治法的思想，找到根结点、左子树的序列、右子树的序列，分别判断左右子序列是否为二叉树的后序序列。 </p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(self, sequence)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> sequence:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> self.helper(sequence)
     <span class="hljs-comment"># 增加helper函数是因为对于递归来说sequence为空可以作为终止条件，而对于判断BST而言 sequence为空是False</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">(self,sequence)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> sequence:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        root=sequence[<span class="hljs-number">-1</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(sequence)):
            <span class="hljs-keyword">if</span> sequence[i]&gt;root:		<span class="hljs-comment">#通过与root比较，找到左子树序列</span>
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> sequence[i:<span class="hljs-number">-1</span>]:	<span class="hljs-comment">#如果右子树序列有小于root的数直接false</span>
            <span class="hljs-keyword">if</span> right&lt;root:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
            <span class="hljs-comment">#返回前后序列是否都是正确的</span>
        <span class="hljs-keyword">return</span> self.helper(sequence[:i]) <span class="hljs-keyword">and</span> self.helper(sequence[i:<span class="hljs-number">-1</span>])</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_22从上往下打印二叉树</title>
    <url>/2019/12/05/%E5%89%91%E6%8C%87offer-22%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显这就是个层次遍历的题目</p>
<p>打算把整个二叉树放在一个栈currentstack里面，然后遍历这个栈，把每个结点的左右子树加到nextstack栈里面，把该结点的值放在res列表里，然后把让这两个栈相等，再遍历这个栈，依次类推，就可以从左到右从上到下遍历整个二叉树了，最后返回res列表即可</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-comment"># class TreeNode:</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> []
        res=[]
        currentstack=[root]
        
        <span class="hljs-keyword">while</span> currentstack:
            nextstack=[]
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> currentstack:
                <span class="hljs-keyword">if</span> i.left:
                    nextstack.append(i.left)
                <span class="hljs-keyword">if</span> i.right:
                    nextstack.append(i.right)
                res.append(i.val)
            currentstack=nextstack
        <span class="hljs-keyword">return</span> res</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_21栈的压入、弹出序列</title>
    <url>/2019/12/05/%E5%89%91%E6%8C%87offer-21%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>借助一个栈stack来存储从pushV中取出的数据，并且都是取pushV第一个数据，在stack末尾加入这个元素，然后依次遍历popV中的元素，如果第一个元素相同，就把pushV和popV中的第一个元素都弹出，如果stack中的最后一个元素与popV中的第一个元素相同，就两个都弹出；如果pushV有数据，就压入stack，如果上述情况都不满足，就直接返回False</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(self, pushV, popV)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        stack=[]
        <span class="hljs-keyword">while</span> popV:
            <span class="hljs-keyword">if</span> pushV <span class="hljs-keyword">and</span> pushV[<span class="hljs-number">0</span>]==popV[<span class="hljs-number">0</span>]:
                pushV.pop(<span class="hljs-number">0</span>)
                popV.pop(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">elif</span> stack <span class="hljs-keyword">and</span> stack[<span class="hljs-number">-1</span>]==popV[<span class="hljs-number">0</span>]:
                stack.pop()
                popV.pop(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">elif</span> pushV:
                stack.append(pushV.pop(<span class="hljs-number">0</span>))
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_20包含min函数的栈</title>
    <url>/2019/12/05/%E5%89%91%E6%8C%87offer-20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>定义一个列表list_a，然后把栈直接当列表来处理，append从末尾加入，pop从末尾出，和栈的先进后出一样，list_a[-1]也就是栈顶top，求最小值可以用列表的min函数，运行可以通过，但是min函数，时间复杂度肯定不是O(1)，绝对超了</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.list_a=[]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, node)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        self.list_a.append(node)
        <span class="hljs-keyword">return</span> self.list_a
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        <span class="hljs-keyword">return</span> self.list_a.pop()
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        <span class="hljs-keyword">return</span> self.list_a[<span class="hljs-number">-1</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        <span class="hljs-keyword">return</span> min(self.list_a)</code></pre></div>

<p>第二种方法就是用空间复杂度来替代时间复杂度，也就是再建个栈，也就是列表来存放最小值</p>
<p>比如 栈 3，4，2，5，1  </p>
<p>辅助栈 3，3，2，2，1</p>
<p>每次入栈的时候，就与辅助栈顶进行比较大小，如果小就入栈和辅助栈，如果大就只入栈，而辅助栈依旧入栈顶；出栈的时候，则两个栈都要出栈，这样就可以保证辅助栈顶一定是当前栈的最小值</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.stack = []
        self.assist = []
         
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, node)</span>:</span>
        min = self.min()
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> min <span class="hljs-keyword">or</span> node &lt; min:
            self.assist.append(node)		<span class="hljs-comment">#小于就把这个值入辅助栈</span>
        <span class="hljs-keyword">else</span>:
            self.assist.append(min)			<span class="hljs-comment">#否则就把原本辅助栈顶的元素再一次入辅助栈</span>
        self.stack.append(node)
         
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> self.stack:
            self.assist.pop()
            <span class="hljs-keyword">return</span> self.stack.pop()
     
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        <span class="hljs-keyword">if</span> self.stack:
            <span class="hljs-keyword">return</span> self.stack[<span class="hljs-number">-1</span>]
         
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        <span class="hljs-keyword">if</span> self.assist:
            <span class="hljs-keyword">return</span> self.assist[<span class="hljs-number">-1</span>]</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_19顺时针打印矩阵</title>
    <url>/2019/12/05/%E5%89%91%E6%8C%87offer-19%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
</tr>
<tr>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
</tr>
</tbody></table>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>在python里面，二维矩阵就是列表的嵌套</p>
<p>[[1,2,3,4],</p>
<p>[5,6,7,8],</p>
<p>[9,10,11,12],</p>
<p>[13,14,15,16] ]</p>
<p>所以可以每次取外面列表的第一位，也就是获得了第一行，同时去除掉第一行，</p>
<p>此时就剩[[5,6,7,8],[9,10,11,12],[13,14,15,16]],然后遍历剩下的，取每一个列表里面最后的那个数，同时也删除这些数，也就剩下[[5,6,7],[9,10,11],[13,14,15]],再取最后一个列表的倒序，同时删除最后一个列表，也就剩下[[5,6,7],[9,10,11]]，最后在倒序一下整个列表[[9,10,11],[5,6,7]]进行遍历，取第一个数，同时删除第一个数，此时剩下[[6,7],[10,11]]，再开始新的一轮循环</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-comment"># matrix类型为二维列表，需要返回列表</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printMatrix</span><span class="hljs-params">(self, matrix)</span>:</span>
        <span class="hljs-comment"># write code here</span>


        res = []
        <span class="hljs-keyword">while</span> matrix:
            res += matrix.pop(<span class="hljs-number">0</span>)			<span class="hljs-comment">#取第一行</span>
            <span class="hljs-keyword">if</span> matrix <span class="hljs-keyword">and</span> matrix[<span class="hljs-number">0</span>]:		<span class="hljs-comment">#判断整个矩阵和且第一个矩阵不为空</span>
                <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> matrix:
                    res.append(row.pop())			<span class="hljs-comment">#取右边的一列</span>
            <span class="hljs-keyword">if</span> matrix:
                res += matrix.pop()[::<span class="hljs-number">-1</span>]			<span class="hljs-comment">#取最下面一行的倒序</span>
            <span class="hljs-keyword">if</span> matrix <span class="hljs-keyword">and</span> matrix[<span class="hljs-number">0</span>]:
                <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> matrix[::<span class="hljs-number">-1</span>]:		
                    res.append(row.pop(<span class="hljs-number">0</span>))			<span class="hljs-comment">#取左边的一列，从下往上取</span>
        <span class="hljs-keyword">return</span> res</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_18二叉树的镜像</title>
    <url>/2019/12/05/%E5%89%91%E6%8C%87offer-18%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><div class="hljs"><pre><code class="hljs angelscript">二叉树的镜像定义：源二叉树 
    	    <span class="hljs-number">8</span>
    	   /  \
    	  <span class="hljs-number">6</span>   <span class="hljs-number">10</span>
    	 / \  / \
    	<span class="hljs-number">5</span>  <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span>
    	镜像二叉树
    	    <span class="hljs-number">8</span>
    	   /  \
    	  <span class="hljs-number">10</span>   <span class="hljs-number">6</span>
    	 / \  / \
    	<span class="hljs-number">11</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span>  <span class="hljs-number">5</span></code></pre></div>



<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>依次每一层交换左右子树就可以了</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
 <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>
     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span>
         self.val = x
         self.left = <span class="hljs-literal">None</span>
         self.right = <span class="hljs-literal">None</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-comment"># 返回镜像树的根节点</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:
            <span class="hljs-keyword">return</span> root
        node=root.left
        root.left=root.right
        root.right=node
        self.Mirror(root.left)
        self.Mirror(root.right)
        <span class="hljs-keyword">return</span> root</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_17树的子结构</title>
    <url>/2019/12/04/%E5%89%91%E6%8C%87offer-17%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先理解子结构和子树的区别</p>
<p>子树的意思是只要包含了一个结点，就得包含这个结点下的所有节点，也就是必须包含最后的叶子结点<br>子结构的意思是包含了一个结点，可以只取左子树或者右子树，或者都不取。 </p>
<p>我打算递归调用HasSubtree遍历二叉树A。如果发现某一节点的值和树B的根结点的值相等，则调用DoesTree1HaveTree2,进行第二步判断。 </p>
<p>第二步是判断树A中以R为跟结点的子树是不是和树B具有相同的结构。同样，我们也可以用递归的思路来考虑：如果节点R的值和树B的根节点不同，那么以R为根节点的子树和树B肯定不具有相同的节点；如果它们的值相同，那么递归地判断它们各自的左右节点的值是不是相同。递归的终止条件是到达了树A或者树B的叶子节点。 </p>
<p>需要注意的是 DoesTree1HasTree2函数中，如果Tree2为空，则说明第二棵树遍历完了，即是第一颗树的子树，返回TRUE  </p>
<p>如果tree1为空而tree2不为空说明tree2结构超大，tree1中不存在</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(self, pRoot1, pRoot2)</span>:</span>
		<span class="hljs-comment"># write code here</span>
        result = <span class="hljs-literal">False</span>
        <span class="hljs-keyword">if</span>  pRoot1 <span class="hljs-keyword">and</span>  pRoot2:				
            <span class="hljs-keyword">if</span> pRoot1.val==pRoot2.val:		<span class="hljs-comment">#如果根节点相同，再进行判断是不是子树</span>
                result = self.DoesTree1HaveTree2(pRoot1,pRoot2)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:		<span class="hljs-comment">#如果根节点不同，那就判断左边有没有相同的结点</span>
                result = self.HasSubtree(pRoot1.left,pRoot2)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result:		<span class="hljs-comment">#最后判断右边有没有相同的结点</span>
                result = self.HasSubtree(pRoot1.right,pRoot2)
        <span class="hljs-keyword">return</span> result
     
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DoesTree1HaveTree2</span><span class="hljs-params">(self,pRoot_A,pRoot_B)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pRoot_B:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pRoot_A:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
        <span class="hljs-keyword">if</span> pRoot_A.val != pRoot_B.val:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
         
        <span class="hljs-keyword">return</span> self.DoesTree1HaveTree2(pRoot_A.left,pRoot_B.left) <span class="hljs-keyword">and</span> self.DoesTree1HaveTree2(pRoot_A.right,pRoot_B.right)</code></pre></div>



<p>大神的做法，是直接先序遍历，然后拼接成字符串，然后比较字符串B在不在字符串A里面，以此来判断是不是子结构，但是有一点点小bug，就是针对</p>
<p>二叉树A</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>2</td>
<td></td>
</tr>
<tr>
<td></td>
<td>3</td>
<td></td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>二叉树B</p>
<table>
<thead>
<tr>
<th></th>
<th>2</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td></td>
<td>4</td>
</tr>
</tbody></table>
<p>这种的话，就会出现错误，</p>
<p>A先序遍历是12354，B先序遍历是234，显然不在里面，但B又是A的子结构</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(self, pRoot1, pRoot2)</span>:</span>
         
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span><span class="hljs-params">(p)</span>:</span>
            <span class="hljs-keyword">if</span> p:
                <span class="hljs-keyword">return</span>  str(p.val)+convert(p.left) + convert(p.right)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>
        <span class="hljs-keyword">return</span> convert(pRoot2) <span class="hljs-keyword">in</span> convert(pRoot1) <span class="hljs-keyword">if</span> pRoot2 <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span></code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_16合并两个排序的链表</title>
    <url>/2019/12/04/%E5%89%91%E6%8C%87offer-16%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>比较两个链表的首结点，哪个小的的结点则合并到第三个链表尾结点，并向前移动一个结点。</li>
<li>步骤一结果会有一个链表先遍历结束，或者没有</li>
<li>第三个链表尾结点指向剩余未遍历结束的链表</li>
<li>返回第三个链表首结点</li>
</ul>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span>
        self.val = x
        self.next = <span class="hljs-literal">None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-comment"># 返回合并后列表</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Merge</span><span class="hljs-params">(self, pHead1, pHead2)</span>:</span>

        <span class="hljs-comment"># write code here</span>

        dummy = ListNode(<span class="hljs-number">0</span>)
        pHead = dummy

        <span class="hljs-keyword">while</span> pHead1 <span class="hljs-keyword">and</span> pHead2:
            <span class="hljs-keyword">if</span> pHead1.val &gt;= pHead2.val:		<span class="hljs-comment">#链表二的结点小，则链表三指向该结点，然后链表二指针后移</span>
                dummy.next = pHead2
                pHead2 = pHead2.next
            <span class="hljs-keyword">else</span>:
                dummy.next = pHead1
                pHead1 = pHead1.next

            dummy = dummy.next

        <span class="hljs-keyword">if</span> pHead1:					<span class="hljs-comment">#判断链表是否为空，指向余下的链结点</span>
            dummy.next = pHead1
        <span class="hljs-keyword">elif</span> pHead2:
            dummy.next = pHead2

        <span class="hljs-keyword">return</span> pHead.next


LN=ListNode(<span class="hljs-number">1</span>)
LN_1=ListNode(<span class="hljs-number">2</span>)
LN_2=ListNode(<span class="hljs-number">3</span>)
LN_3=ListNode(<span class="hljs-number">4</span>)
LN.next=LN_1
LN_1.next=LN_2
LN_2.next=LN_3

LNN=ListNode(<span class="hljs-number">2</span>)
LNN_1=ListNode(<span class="hljs-number">3</span>)
LNN_2=ListNode(<span class="hljs-number">4</span>)
LNN_3=ListNode(<span class="hljs-number">5</span>)
LNN.next=LNN_1
LNN_1.next=LNN_2
LNN_2.next=LNN_3

S1=Solution()
print(S1.Merge(LN,LNN))</code></pre></div>

<p>采用递归也可以，但时间复杂度比较大</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-comment"># 返回合并后列表</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Merge</span><span class="hljs-params">(self, pHead1, pHead2)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        <span class="hljs-keyword">if</span> pHead1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> pHead2
        <span class="hljs-keyword">if</span> pHead2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> pHead1
        <span class="hljs-keyword">if</span> pHead1.val &lt; pHead2.val:				<span class="hljs-comment">#链表一结点小，就指向递归后的次小</span>
            pHead1.next = self.Merge(pHead1.next,pHead2)
            <span class="hljs-keyword">return</span> pHead1
        <span class="hljs-keyword">else</span>:
            pHead2.next = self.Merge(pHead1,pHead2.next)
            <span class="hljs-keyword">return</span> pHead2</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_15反转链表</title>
    <url>/2019/12/04/%E5%89%91%E6%8C%87offer-15%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>遍历整个链表，然后让头结点指向空，其他结点依次指向前一个结点，这样就达到了反转链表。先定义一个last指针，指向为空，然后定义一个temp指针指向头结点的下一个，</p>
<p>链表这样1—-&gt;2——&gt;3——-&gt;4</p>
<p>一个循环的具体过程：</p>
<ul>
<li>先让temp指针指向pHead所指元素的下一个，此时last指向空        </li>
</ul>
<table>
<thead>
<tr>
<th>pHead（指向1）</th>
<th>temp</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1—————&gt;</td>
<td>2——————&gt;</td>
<td>3———————&gt;</td>
<td>4————————&gt;NuLL</td>
</tr>
</tbody></table>
<ul>
<li>然后让pHead所指元素的下一个指向last所指的元素（也就是前一个元素）</li>
</ul>
<table>
<thead>
<tr>
<th align="left">last(指向Null)      pHead(指向1）</th>
<th align="left">temp</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Null&lt;—————1</td>
<td align="left">2——–——&gt;</td>
<td>3————&gt;</td>
<td>4————&gt;NuLL</td>
</tr>
</tbody></table>
<ul>
<li>然后再移动last指针，使它和pHead指向同一个，</li>
</ul>
<table>
<thead>
<tr>
<th align="right">last pHead(都指向1)</th>
<th>temp</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="right">Null&lt;———————1</td>
<td>2——————&gt;</td>
<td>3———————&gt;</td>
<td>4————————&gt;NuLL</td>
</tr>
</tbody></table>
<ul>
<li>最后让pHead指向temp所指的元素</li>
</ul>
<table>
<thead>
<tr>
<th align="right">last（指向1）</th>
<th>temp pHead</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="right">Null&lt;—–—————1</td>
<td>2——————&gt;</td>
<td>3———————&gt;</td>
<td>4————————&gt;NuLL</td>
</tr>
</tbody></table>
<p>依次执行循环，知道最后pHead指向空，此时last指向最后一个结点（也就是反转后的第一个结点），跳出循环</p>
<p>特殊情况就是这个链表只有一个结点的时候，就直接输出这个结点</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span>
        self.val = x
        self.next = <span class="hljs-literal">None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-comment"># 返回ListNode</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReverseList</span><span class="hljs-params">(self, pHead)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pHead <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> pHead.next:
            <span class="hljs-keyword">return</span> pHead

        last = <span class="hljs-literal">None</span>

        <span class="hljs-keyword">while</span> pHead:
            tmp = pHead.next
            pHead.next = last
            last = pHead
            pHead = tmp

        <span class="hljs-comment">#return last.val</span>
        <span class="hljs-keyword">return</span> last

LN=ListNode(<span class="hljs-number">1</span>)
LN_1=ListNode(<span class="hljs-number">2</span>)
LN_2=ListNode(<span class="hljs-number">3</span>)
LN_3=ListNode(<span class="hljs-number">4</span>)
LN.next=LN_1
LN_1.next=LN_2
LN_2.next=LN_3


s1=Solution()
print(s1.ReverseList(LN))</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_14链表中倒数第K个结点</title>
    <url>/2019/12/04/%E5%89%91%E6%8C%87offer-14%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>第一种解法定义一个res列表，然后进行遍历整个链表，把一个个节点存储进res列表里，然后再输出倒数第k个结点</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span>
        self.val = x
        self.next = <span class="hljs-literal">None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(self, head, k)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        res=[]
        <span class="hljs-keyword">while</span> head:
            res.append(head)
            head=head.next
        <span class="hljs-keyword">if</span> k&gt;len(res) <span class="hljs-keyword">or</span> k&lt;<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-comment">#return res[-k].val</span>
        <span class="hljs-keyword">return</span> res[-k]

LN=ListNode(<span class="hljs-number">1</span>)
LN_1=ListNode(<span class="hljs-number">2</span>)
LN_2=ListNode(<span class="hljs-number">3</span>)
LN_3=ListNode(<span class="hljs-number">4</span>)
LN.next=LN_1
LN_1.next=LN_2
LN_2.next=LN_3
<span class="hljs-comment">#形成了LN--&gt;LN_1--&gt;LN_2--&gt;LN_3的一个链表</span>

s1=Solution()
print(s1.FindKthToTail(LN,<span class="hljs-number">2</span>))</code></pre></div>

<p>第二种解法是定义两个指针，让一个指针先走k-1次，而另一个指针不动，然后再两个指针同时移动，直到前面那个指针到了最后一个，次数后面那个指针刚好就是指向倒数第K个节点，输出该指针指向的结点即可</p>
<div class="hljs"><pre><code class="hljs python">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(self, head, k)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        <span class="hljs-keyword">if</span> head==<span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> k&lt;=<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-comment">#设置两个指针，p2指针先走（k-1）步，然后再一起走，当p2为最后一个时，p1就为倒数第k个</span>
        p2=head
        p1=head
        <span class="hljs-comment">#p2先走，走k-1步，如果k大于链表长度则返回 空，否则的话继续走</span>
        <span class="hljs-keyword">while</span> k&gt;<span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> p2.next!=<span class="hljs-literal">None</span>:
                p2=p2.next
                k-=<span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
<span class="hljs-comment">#两个指针一起 走，一直到p2为最后一个,p1即为所求</span>
        <span class="hljs-keyword">while</span> p2.next!=<span class="hljs-literal">None</span>:
            p1=p1.next
            p2=p2.next
        <span class="hljs-keyword">return</span> p1</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_13调整数组顺序使奇数位于偶数前面</title>
    <url>/2019/12/04/%E5%89%91%E6%8C%87offer-13%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先创建两个空列表a和b用来存储奇数和偶数，然后遍历传入的数组，用%取余符号来判断是奇数还是偶数，奇数就存入a列表，偶数就存入b列表，之后再把b列表拼接到a列表后面就可以了</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(array)</span>:</span>
    a=[]
    b=[]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array:
        <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>:
            a.append(i)
        <span class="hljs-keyword">else</span>:
            b.append(i)
    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> b:
        a.append(num)
    <span class="hljs-keyword">return</span> a

a=[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>]
print(reOrderArray(a))</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_12数值的整数次方</title>
    <url>/2019/12/04/%E5%89%91%E6%8C%87offer-12%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和exponent不同时为0</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先想到的就是直接base**exponent,但是感觉这很明显就不是要考察的</p>
<p>那就开始分析一下</p>
<ul>
<li>底数不能为0</li>
<li>指数是0的时候，底数不管多少都是1</li>
<li>指数是负数的时候，结果应该是多少分之一</li>
</ul>
<p>然后就是用for循环遍历一下，几次方就循环自乘几次</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Power</span><span class="hljs-params">(base,exponent)</span>:</span>
    result=<span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> base==<span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> exponent==<span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> exponent&lt;<span class="hljs-number">0</span>:
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(-exponent):
            result=result*base
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>/result
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(exponent):
            result=result*base
        <span class="hljs-keyword">return</span> result


print(Power(<span class="hljs-number">2.0</span>,<span class="hljs-number">4</span>))</code></pre></div>



]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_11二进制中1的个数</title>
    <url>/2019/12/03/%E5%89%91%E6%8C%87offer-11%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>如果是负数，就用0xffffffff进行与运算，为什么是8个f呢，因为32位来表示。</p>
<p>如果n!=0，n的二进制中至少有一个1</p>
<ul>
<li>如果1在最低位，n-1 &amp; n得到的数正好将这个1，变成0</li>
<li>如果1不在最低位，n-1 &amp; n得到的数正好将这个1，变成0</li>
</ul>
<p>因此我们判断n-1 &amp; n能够循环运行的次数就可以判断二进制中有多少个1了。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(n)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        count = <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>:
            n = n &amp; <span class="hljs-number">0xffffffff</span>
        <span class="hljs-keyword">while</span> n:
            count += <span class="hljs-number">1</span>
            n = (n - <span class="hljs-number">1</span>) &amp; n

        <span class="hljs-keyword">return</span> count


print(NumberOf1(<span class="hljs-number">5</span>))</code></pre></div>

<p>5的二进制是0000 0000 0000 0000 0000 0000 0000 0101</p>
<p>所以结果是2</p>
<p>-3的二进制是1111 1111 1111 1111 1111 1111 1111 1101</p>
<p>所以结果是31</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_10矩阵覆盖</title>
    <url>/2019/12/03/%E5%89%91%E6%8C%87offer-10%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们可以用 2 * 1 的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>画图理解，找规律</p>
<img src="/2019/12/03/%E5%89%91%E6%8C%87offer-10%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96/tu.png" srcset="/img/loading.gif" class title="picture">

<p>f(1) = 1 </p>
<p>f(2) = 2</p>
<p>f(3)=f(2)+f(1)</p>
<p>故f(n) = f(n-1) + f(n-2)</p>
<p>所以依旧是斐波那契数列，直接用循环</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rectCover</span><span class="hljs-params">(number)</span>:</span>
       a=<span class="hljs-number">1</span>
       b=<span class="hljs-number">2</span>

       <span class="hljs-keyword">if</span> number==<span class="hljs-number">0</span>:
           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
       <span class="hljs-keyword">if</span> number==<span class="hljs-number">1</span>:
           <span class="hljs-keyword">return</span> a
       <span class="hljs-keyword">if</span> number==<span class="hljs-number">2</span>:
           <span class="hljs-keyword">return</span> b
       <span class="hljs-keyword">else</span>:
           <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(number<span class="hljs-number">-1</span>):
               a,b=b,a+b
           <span class="hljs-keyword">return</span> a</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_09变态跳台阶</title>
    <url>/2019/12/03/%E5%89%91%E6%8C%87offer-09%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比起前一题的要求是可以跳上n级,依旧画表格演示</p>
<table>
<thead>
<tr>
<th>台阶</th>
<th>跳法（1表示跳一次1阶，2表示跳一次2阶，3表示跳一次3阶）</th>
<th>跳法次数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>（1，1）,（2）</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>（1，1，1），（1，2），（2，1），（3）</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>（1，1，1，1），（1，1，2），（1，2，1），（2，1，1），（2，2）       （1，3），（3，1），（4）</td>
<td>8</td>
</tr>
</tbody></table>
<p>f(1)=1, f(2)=2, f(3)=4, f(4)=8 </p>
<p>f(2)=f(2-1)+f(2-2)=f(1)+f(0)                    #f(2-1)表示2阶一次跳1阶的次数，类似于上一题最后递归 </p>
<p>f(3)=f(3-1)+f(3-2)+f(3-3)=f(2)+f(1)+f(0)</p>
<p>可知f(0)=1</p>
<p>设n+1级f(n+1),有</p>
<p>f(n+1) = f(0)+f(1) + f(2) + … + f(n)</p>
<p>f(n+2) = f(0)+f(1) + f(2) + … + f(n+1)</p>
<p>f(n+2)= f(0)+f(1) + f(2) + … + f(n)+f(1)+f(2)+…+f(n)=2【f(0)+f(1)+f(2)+…+f(n)】=2f(n+1)</p>
<p>其实这是一个无穷级数的题目，故f（n）=2f(n-1)=2*2f(n-2)</p>
<p>所以f(n)=2^(n-1)</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(number)</span>:</span>
 
    f1 = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> number == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> f1			
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(number<span class="hljs-number">-1</span>):
        f1 = <span class="hljs-number">2</span>*f1
    <span class="hljs-keyword">return</span> f1
	<span class="hljs-comment">#return 2**(number-1)		#或者直接2^（number-1）</span></code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_08跳台阶</title>
    <url>/2019/12/03/%E5%89%91%E6%8C%87offer-08%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一开始我以为直接两个for循环，判断i+2*j=n就行了，结果发现这样会漏掉次数，比如跳三阶台阶，跳法可以是跳三次一阶，或者先跳一次两阶和再一次一阶，或者先跳一次一阶，再跳一次两阶。</p>
<p>画个表格来演示下</p>
<table>
<thead>
<tr>
<th>台阶</th>
<th>跳法（1代表跳一次一阶，2代表跳一次2阶）</th>
<th>跳法次数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>（1，1），（2）</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>（1，1，1），（1，2），（2，1）</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>（1，1，1，1），（1，1，2）（1，2，1），（2，1，1），（2，2）</td>
<td>5</td>
</tr>
</tbody></table>
<p>逐渐发现规律了，f（1）=1</p>
<p>​                               f（2）=2</p>
<p>​                               f（3）=f（1）+f（2）</p>
<p>​                               f（4）=f（2）+f（3）</p>
<p>显然了，这就是一个斐波那契数列</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#递归，然而时间复杂度比较大</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(number)</span>:</span>
        <span class="hljs-keyword">if</span> number==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> number==<span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> jumpFloor(number<span class="hljs-number">-1</span>)+jumpFloor(number<span class="hljs-number">-2</span>)
   
<span class="hljs-comment">#循环</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">( number)</span>:</span>
    <span class="hljs-comment"># write code here</span>
    a = <span class="hljs-number">1</span>
    b = <span class="hljs-number">2</span>
    <span class="hljs-keyword">if</span> number==<span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> a
    <span class="hljs-keyword">if</span> number==<span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> b
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">for</span> _  <span class="hljs-keyword">in</span> range(number<span class="hljs-number">-1</span>):
            a,b=b,a+b
    <span class="hljs-keyword">return</span> a

print(jumpFloor(<span class="hljs-number">4</span>))</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_07斐波那契数列</title>
    <url>/2019/12/02/%E5%89%91%E6%8C%87offer-07%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）n&lt;=39</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法有两种，第一种就是最常规的解法，用递归方法，缺点是时间复杂度太大了，第二种就是用循环，然后每次循环进行a，b值的交换，a=b，b=a+b，第三种方法也是用循环，先定义一个列表，然后每次都末尾追加最后两项相加之后的和</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#递归</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(n)</span>:</span>
    a=<span class="hljs-number">0</span>
    b=<span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> a
    <span class="hljs-keyword">elif</span> n==<span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> b
    <span class="hljs-keyword">else</span>:
    	<span class="hljs-keyword">return</span> Fibonacci(n<span class="hljs-number">-1</span>)+Fibonacci(n<span class="hljs-number">-2</span>)
    
<span class="hljs-comment">#循环</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(n)</span>:</span>
    a=<span class="hljs-number">0</span>
    b=<span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> a
    <span class="hljs-keyword">elif</span> n==<span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> b
    <span class="hljs-keyword">else</span>:
    	<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n):
            a,b=b,a+b
    <span class="hljs-keyword">return</span> a
		

<span class="hljs-comment">#循环</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(n)</span>:</span>
   
    a = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
    <span class="hljs-keyword">while</span> len(a) &lt;= n:
        a.append(a[<span class="hljs-number">-1</span>] + a[<span class="hljs-number">-2</span>])
    <span class="hljs-keyword">return</span> a[n]</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_06旋转数组的最小数字</title>
    <url>/2019/12/02/%E5%89%91%E6%8C%87offer-06%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先说明了是非递减排序的数列，即旋转后不会出现{5，4，3，1，2}，也就是旋转后的数组依旧是由两个非递减数组组成，如{3，4，5，1，2}由3，4，5和1，2组成，故只需要两两依次比较即可，如果后面的那个数小于前面的就return后面那个数，即可</p>
<p>当然python也有min函数，可以直接求出最小的数；也可以用sort排序后，直接取第一个数，也是最小的数，但这显然不是本题要考察的</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span>

<span class="hljs-comment">#min函数的方法</span>
<span class="hljs-comment">#min(rotateArray)</span>

<span class="hljs-comment">#sort排序的方法</span>
<span class="hljs-comment">#rotateArray.sort()</span>
<span class="hljs-comment">#print(rotateArray[0])</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">( rotateArray)</span>:</span>
        <span class="hljs-comment"># write code here</span>
        length = len(rotateArray)
        <span class="hljs-keyword">if</span> length == <span class="hljs-number">0</span>:
           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">elif</span> length == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> rotateArray[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length<span class="hljs-number">-1</span>):
                <span class="hljs-keyword">if</span> rotateArray[i] &gt; rotateArray[i+<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">return</span> rotateArray[i+<span class="hljs-number">1</span>]
            <span class="hljs-keyword">return</span> rotateArray[<span class="hljs-number">0</span>]

a=[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
print(minNumberInRotateArray(a))</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_05用两个栈实现队列</title>
    <url>/2019/12/02/%E5%89%91%E6%8C%87offer-05%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>append函数都是在末尾追加，故用stackA模拟进队操作</p>
<p>pop函数默认从末尾删除，故从stackA里面删除，然后把该元素添加进stackB里面，然后再从stackB里面pop出来，即实现了队列的先进先出</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.stackA=[]      <span class="hljs-comment">#入队使用的栈A</span>
        self.stackB=[]      <span class="hljs-comment">#出队使用的栈B</span>


    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self,node)</span>:</span>
        self.stackA.append(node)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.stackB:		<span class="hljs-comment">#栈B为空的时候就执行把A的元素依次进来</span>
            <span class="hljs-keyword">while</span> self.stackA:
                self.stackB.append(self.stackA.pop())

        <span class="hljs-keyword">return</span> self.stackB.pop()

    
a=Solution()
a.push(<span class="hljs-number">1</span>)
a.push(<span class="hljs-number">2</span>)
a.push(<span class="hljs-number">3</span>)
print(a.pop())
print(a.pop())
print(a.pop())</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络层</title>
    <url>/2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h5 id="两种服务："><a href="#两种服务：" class="headerlink" title="两种服务："></a>两种服务：</h5><ul>
<li>虚电路服务：建立连接、有短的虚电路号、顺序到达</li>
<li>数据报服务：无连接、有终点的完整地址、不一定顺序到达</li>
</ul>
<h5 id="主要协议："><a href="#主要协议：" class="headerlink" title="主要协议："></a>主要协议：</h5><p>IP网际协议、ARP地址解析协议、ICMP网际控制报文协议、IGMP网际组管理协议</p>
<p>IP地址=网络号+主机号     32位标识符</p>
<p>IP地址——ARP——&gt;硬件地址        每台主机都有一个ARP告诉缓存</p>
<p><strong>ARP</strong>是解决同一局域网上的主机或路由器的IP地址和硬件地址的转换</p>
<h5 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h5><p><strong>IP数据报格式</strong>：首部+数据</p>
<p>首部：固定长度20字节+可选字段</p>
<p>最长首部：60字节      最大数据报：576字节</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>首部长度</th>
<th>区分服务</th>
<th>总长度</th>
<th>标识</th>
<th>标志</th>
<th>片偏移</th>
<th>生存时间</th>
<th>协议</th>
<th>首部校验和</th>
<th>源地址</th>
<th>目的地址</th>
</tr>
</thead>
<tbody><tr>
<td>4位</td>
<td>4位</td>
<td>8位</td>
<td>16位</td>
<td>16位</td>
<td>3位</td>
<td>13位</td>
<td>8位</td>
<td>8位</td>
<td>16位</td>
<td>32位</td>
<td>32位</td>
</tr>
</tbody></table>
<p>三级IP地址：网络号+子网号+主机号</p>
<p>变长子网掩码VLSM        无分类域间路由选择CIDR      </p>
<p>IP地址：网络前缀+主机号／前缀占位数</p>
<p><strong>路由聚合</strong>：利用CIDR地址来查找目的网络</p>
<p><strong>最长前缀匹配</strong>：在路由查找中，应当从匹配结果中选择具有最长网络前缀的路由</p>
<p><strong>ICMP报文</strong>：数据报的数据（IP层)+数据报首部，并且ICMP报文作为IP数据报的数据部门</p>
<h5 id="ICMP五种差错报文："><a href="#ICMP五种差错报文：" class="headerlink" title="ICMP五种差错报文："></a>ICMP五种差错报文：</h5><ul>
<li><p>1⃣️终点不可达</p>
</li>
<li><p>2⃣️时间超过</p>
</li>
<li><p>3⃣️参数问题  </p>
</li>
<li><p>4⃣️重定向</p>
</li>
<li><p>5⃣️源点抑制</p>
</li>
</ul>
<h5 id="两种询问报文："><a href="#两种询问报文：" class="headerlink" title="两种询问报文："></a>两种询问报文：</h5><ul>
<li>1⃣️回送请求和回答 </li>
<li>2⃣️时间戳请求和回答</li>
</ul>
<h5 id="路由选择："><a href="#路由选择：" class="headerlink" title="路由选择："></a>路由选择：</h5><ul>
<li>1⃣️静态路由即人工配置</li>
<li>2⃣️动态路由：IGP内部网关协议、BGP外部网关协议</li>
</ul>
<h5 id="IGP内部网关协议："><a href="#IGP内部网关协议：" class="headerlink" title="IGP内部网关协议："></a>IGP内部网关协议：</h5><ul>
<li>RIP 基于距离向量的路由选择协议</li>
<li>OSPF 分布式的链路状态协议，即最短路径优先</li>
</ul>
<h5 id="RIP的特点："><a href="#RIP的特点：" class="headerlink" title="RIP的特点："></a>RIP的特点：</h5><ul>
<li>1⃣️仅和相邻路由交换信息。</li>
<li>2⃣️所交换的信息为自己现在的路由表</li>
<li>3⃣️按固定时间间隔交换</li>
</ul>
<p>RIP报文最大长度为504字节，用UDP传送</p>
<h5 id="OSPF的特点："><a href="#OSPF的特点：" class="headerlink" title="OSPF的特点："></a>OSPF的特点：</h5><ul>
<li>1⃣️向本自治系统中所有路由器发送信息</li>
<li>2⃣️发送信息为相邻的所有路由器的链路状态</li>
<li>3⃣️只有当链路状态发生变化时，才向所有路由采用洪泛法发送信息。    OSPF采用IP数据报进行传送</li>
</ul>
<p>BGP采用距离向量路由选择协议，各自治系统中，BGP发言人（边界路由器）与其它自治系统边界路由器建立TCP连接，交换BGP报文以建立BGP会话、利用BGP会话交换路由信息</p>
<p><strong>IPV6数据报</strong>：基本首部(60 B)+有效载荷(64KB)</p>
<p><strong>IPV6地址类型</strong>：单播、多播、广播，表示方法：冒号十六进制法</p>
<p><strong>IPV4至IPV6过渡策略</strong>：1⃣️双协议栈。2⃣️隧道技术</p>
<p><strong>主要设备</strong>：路由器、三层交换机</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-数据链路层</title>
    <url>/2019/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h5 id="两种信道："><a href="#两种信道：" class="headerlink" title="两种信道："></a>两种信道：</h5><p>1⃣️点对点信道</p>
<p>2⃣️广播信道</p>
<p>数据链路层的<strong>协议数据单位</strong>——————<strong>帧</strong></p>
<h5 id="帧定界："><a href="#帧定界：" class="headerlink" title="帧定界："></a>帧定界：</h5><ul>
<li><p>1⃣️起始字符：SOH</p>
</li>
<li><p>2⃣️终止字符：EOT</p>
</li>
<li><p>3⃣️最大传送单元：MTU</p>
</li>
</ul>
<p><strong>字符填充：</strong></p>
<p>在数据部分中出现SOH、EOT，在其前面加入转义字符<strong>ESC</strong>即可</p>
<h5 id="循环冗余检验CRC："><a href="#循环冗余检验CRC：" class="headerlink" title="循环冗余检验CRC："></a>循环冗余检验CRC：</h5><p>若余数R=0，则无差错，反之则有</p>
<h5 id="多项式表示："><a href="#多项式表示：" class="headerlink" title="多项式表示："></a>多项式表示：</h5><p>P=1101，即P(X)=X^3+X^2+1</p>
<p>p=10011，即P(X)=X^4+X+1</p>
<h5 id="PPP协议的帧格式："><a href="#PPP协议的帧格式：" class="headerlink" title="PPP协议的帧格式："></a>PPP协议的帧格式：</h5><table>
<thead>
<tr>
<th>标志字段F</th>
<th>地址字段A</th>
<th>控制字段C</th>
<th>协议</th>
<th>IP数据报</th>
<th>检验序列FCS</th>
<th>标志字段F</th>
</tr>
</thead>
<tbody><tr>
<td>7E</td>
<td>FF</td>
<td>03</td>
<td>2个字节</td>
<td>不超过1500字节</td>
<td>2个字节</td>
<td>7E</td>
</tr>
</tbody></table>
<h5 id="字节填充-异步传输-："><a href="#字节填充-异步传输-：" class="headerlink" title="字节填充(异步传输)："></a>字节填充(异步传输)：</h5><ul>
<li>1⃣️出现7E，变成7D5E</li>
<li>2⃣️出现7D，变成7D5D</li>
<li>3⃣️出现控制字符，在其前面加7D</li>
</ul>
<h5 id="零比特填充-同步传输-："><a href="#零比特填充-同步传输-：" class="headerlink" title="零比特填充(同步传输)："></a>零比特填充(同步传输)：</h5><p>只要发现有5个连续的1，就立即填入0</p>
<h5 id="广播信道共享技术："><a href="#广播信道共享技术：" class="headerlink" title="广播信道共享技术："></a>广播信道共享技术：</h5><ul>
<li>1⃣️静态划分信道：频分复用、时分复用、波分复用、码分复用</li>
<li>2⃣️动态媒体接入控制(多点介入)：随机接入，受控接入</li>
</ul>
<h5 id="802-3标准："><a href="#802-3标准：" class="headerlink" title="802.3标准："></a>802.3标准：</h5><p>CSMA／CD协议➕物理层规范</p>
<h5 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h5><p>逻辑链路控制LLC➕媒体接入控制MAC</p>
<h5 id="载波监听多点接入／碰撞检测-CSMA-CD-：工作过程"><a href="#载波监听多点接入／碰撞检测-CSMA-CD-：工作过程" class="headerlink" title="载波监听多点接入／碰撞检测(CSMA/CD)：工作过程"></a>载波监听多点接入／碰撞检测(CSMA/CD)：工作过程</h5><ul>
<li>1⃣️先听先发</li>
<li>2⃣️边听边发</li>
<li>3⃣️冲突停发</li>
<li>4⃣️随机重发</li>
</ul>
<h5 id="重发机制："><a href="#重发机制：" class="headerlink" title="重发机制："></a>重发机制：</h5><p>使用截断二进制指数退避算法进行重发，[0，2^k  —1]中任取一个数，k=min[重复次数，10]，当重传达到16次，则丢弃</p>
<h5 id="两类地址"><a href="#两类地址" class="headerlink" title="两类地址"></a>两类地址</h5><ul>
<li>物理地址：MAC地址，48位二进制</li>
<li>逻辑地址：IP地址</li>
</ul>
<h5 id="MAC帧格式："><a href="#MAC帧格式：" class="headerlink" title="MAC帧格式："></a>MAC帧格式：</h5><table>
<thead>
<tr>
<th>目的地址</th>
<th>源地址</th>
<th>类型</th>
<th>IP数据报</th>
<th>FCS</th>
</tr>
</thead>
<tbody><tr>
<td>6字节</td>
<td>6字节</td>
<td>2字节</td>
<td>46～1500字节</td>
<td>4字节</td>
</tr>
</tbody></table>
<p>以太网<strong>不负责重传</strong>丢弃的帧</p>
<h5 id="集线器和交换机的区别"><a href="#集线器和交换机的区别" class="headerlink" title="集线器和交换机的区别"></a>集线器和交换机的区别</h5><p>集线器只进行<strong>转发</strong>而不能把帧进行缓存，交换机则采用<strong>存储转发</strong>的方式</p>
<p>交换机的地址表是通过自学习算法自动建立起来的，且交换机每次都要跑一遍<strong>生成树协议STP</strong></p>
<h5 id="VLAN的优点："><a href="#VLAN的优点：" class="headerlink" title="VLAN的优点："></a>VLAN的优点：</h5><ul>
<li>1⃣️控制网络的广播风暴</li>
<li>2⃣️确保网络的安全性</li>
<li>3⃣️简化网络管理</li>
</ul>
<p><strong>主要设备：</strong>网桥、交换机、桥接器</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_04重建二叉树</title>
    <url>/2019/11/29/%E5%89%91%E6%8C%87offer-04%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,5,3,6,7}和中序遍历序列{4,2,5,1,6,3,7}，则重建二叉树并返回。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>前序遍历的第一个元素就是每次二次的根节点，所以确定在中序遍历中根节点所在的位置就可以把中序遍历一分为二，根节点前面的为左子树的元素，根节点后面的为右子树的元素。每次遍历前，都把前序中的根节点移除。</p>
<p>初始：</p>
<table>
<thead>
<tr>
<th>前序遍历</th>
<th>1</th>
<th>2</th>
<th>4</th>
<th>5</th>
<th>3</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>中序遍历</td>
<td>4</td>
<td>2</td>
<td>5</td>
<td>1</td>
<td>6</td>
<td>3</td>
<td>7</td>
</tr>
</tbody></table>
<p>可知1是根节点，在中序遍历中第3个位置（列表从0开始数），则前三个为左子树的，后三个为右子树的</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#构建二叉树</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span>
        self.val = x        <span class="hljs-comment">#中间节点</span>
        self.left = <span class="hljs-literal">None</span>    <span class="hljs-comment">#左节点</span>
        self.right = <span class="hljs-literal">None</span>   <span class="hljs-comment">#右节点</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(self, pre, tin)</span>:</span>      <span class="hljs-comment">#传入前序遍历序列、中序遍历序列</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pre <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> tin:                  <span class="hljs-comment">#判断是否为空</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        root = TreeNode(pre.pop(<span class="hljs-number">0</span>))             <span class="hljs-comment">#把前序遍历序列的第一个pop出来给root，即根节点</span>

        index = tin.index(root.val)             <span class="hljs-comment">#找根节点在中序遍历的那个位置，然后分割左右子树</span>
        root.left = self.reConstructBinaryTree(pre, tin[:index])            <span class="hljs-comment">#先构建左子树，此时的前序序列已经是删去了根节点，中序序列只取序列中，根节点前的元素</span>
        root.right = self.reConstructBinaryTree(pre, tin[index + <span class="hljs-number">1</span>:])       <span class="hljs-comment">#构建右子树，此时的前序序列也是删去了根节点，中序序列只取序列中，根节点后的元素</span>

        <span class="hljs-keyword">return</span> root         <span class="hljs-comment">#返回整棵二叉树</span>

    
<span class="hljs-comment">#再写一个层次遍历，检验二叉树构建是否成功</span>
<span class="hljs-comment">#思路是遍历queue中的以每一个节点为根节点的树，然后存储到outlist里面，然后删除根节点，加入左右子树，继续遍历</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">( root)</span>:</span>

    outList=[]      <span class="hljs-comment">#建立一个列表来存储</span>
    queue=[root]        <span class="hljs-comment">#把二叉树放到queue列表里</span>
    <span class="hljs-keyword">while</span> queue!=[] <span class="hljs-keyword">and</span> root:           <span class="hljs-comment">#queue不为空，且root不为空</span>
        outList.append(queue[<span class="hljs-number">0</span>].val)        <span class="hljs-comment">#把二叉树的根节点加入到outlist列表里</span>
        <span class="hljs-keyword">if</span> queue[<span class="hljs-number">0</span>].left!=<span class="hljs-literal">None</span>:             <span class="hljs-comment">#如果左子树不为空，则也添加到queue队列里</span>
            queue.append(queue[<span class="hljs-number">0</span>].left)
        <span class="hljs-keyword">if</span> queue[<span class="hljs-number">0</span>].right!=<span class="hljs-literal">None</span>:            <span class="hljs-comment">#如果右子树不为空，则也添加到queue队列里</span>
            queue.append(queue[<span class="hljs-number">0</span>].right)
        queue.pop(<span class="hljs-number">0</span>)                    <span class="hljs-comment">#删除queue的根节点</span>
    <span class="hljs-keyword">return</span> outList


sl=Solution()
s1=sl.reConstructBinaryTree([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>])

print(PrintFromTopToBottom(s1))
<span class="hljs-comment">#层序遍历的结果为1，2，3，4，5，6，7，即构建二叉树成功</span>
<span class="hljs-comment">#可自己动手画一下二叉树，遍历一下检验是否有误</span></code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo文章插入图片不显示</title>
    <url>/2019/11/28/hexo%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="一、修改配置文件"><a href="#一、修改配置文件" class="headerlink" title="一、修改配置文件"></a>一、修改配置文件</h3><p>修改根目录下的_config.yml文件，原本是false，改成true，之后新建文章的时候会生成一个文章同名的文件夹，把照片放进去就可以了</p>
<div class="hljs"><pre><code class="hljs shell">post_asset_folder: true</code></pre></div>



<h3 id="二、安装插件"><a href="#二、安装插件" class="headerlink" title="二、安装插件"></a>二、安装插件</h3><p> 我们需要安装一个图片路径转换的插件，这个插件名字是<strong>hexo-asset-image</strong> </p>
<div class="hljs"><pre><code class="hljs shell">npm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre></div>

<p>但是这个插件的内容需要修改【不然可能会出Bug】</p>
<p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p>
<div class="hljs"><pre><code class="hljs js"><span class="hljs-meta">'use strict'</span>;
<span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cheerio'</span>);

<span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">str, m, i</span>) </span>&#123;
  <span class="hljs-keyword">return</span> str.split(m, i).join(m).length;
&#125;

<span class="hljs-keyword">var</span> version = <span class="hljs-built_in">String</span>(hexo.version).split(<span class="hljs-string">'.'</span>);
hexo.extend.filter.register(<span class="hljs-string">'after_post_render'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;
  <span class="hljs-keyword">var</span> config = hexo.config;
  <span class="hljs-keyword">if</span>(config.post_asset_folder)&#123;
    	<span class="hljs-keyword">var</span> link = data.permalink;
	<span class="hljs-keyword">if</span>(version.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)
	   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">'/'</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">else</span>
	   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">'/'</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;
	<span class="hljs-comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span>
	<span class="hljs-keyword">var</span> endPos = link.lastIndexOf(<span class="hljs-string">'/'</span>) + <span class="hljs-number">1</span>;
    link = link.substring(beginPos, endPos);

    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">'excerpt'</span>, <span class="hljs-string">'more'</span>, <span class="hljs-string">'content'</span>];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.length; i++)&#123;
      <span class="hljs-keyword">var</span> key = toprocess[i];
 
      <span class="hljs-keyword">var</span> $ = cheerio.load(data[key], &#123;
        <span class="hljs-attr">ignoreWhitespace</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">xmlMode</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">lowerCaseTags</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">decodeEntities</span>: <span class="hljs-literal">false</span>
      &#125;);

      $(<span class="hljs-string">'img'</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
		<span class="hljs-keyword">if</span> ($(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'src'</span>))&#123;
			<span class="hljs-comment">// For windows style path, we replace '\' to '/'.</span>
			<span class="hljs-keyword">var</span> src = $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'src'</span>).replace(<span class="hljs-string">'\\'</span>, <span class="hljs-string">'/'</span>);
			<span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;
			   !<span class="hljs-regexp">/^\s*\//</span>.test(src)) &#123;
			  <span class="hljs-comment">// For "about" page, the first part of "src" can't be removed.</span>
			  <span class="hljs-comment">// In addition, to support multi-level local directory.</span>
			  <span class="hljs-keyword">var</span> linkArray = link.split(<span class="hljs-string">'/'</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;
				<span class="hljs-keyword">return</span> elem != <span class="hljs-string">''</span>;
			  &#125;);
			  <span class="hljs-keyword">var</span> srcArray = src.split(<span class="hljs-string">'/'</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;
				<span class="hljs-keyword">return</span> elem != <span class="hljs-string">''</span> &amp;&amp; elem != <span class="hljs-string">'.'</span>;
			  &#125;);
			  <span class="hljs-keyword">if</span>(srcArray.length &gt; <span class="hljs-number">1</span>)
				srcArray.shift();
			  src = srcArray.join(<span class="hljs-string">'/'</span>);
			  $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'src'</span>, config.root + link + src);
			  <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">"update link as:--&gt;"</span>+config.root + link + src);
			&#125;
		&#125;<span class="hljs-keyword">else</span>&#123;
			<span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">"no src attr, skipped..."</span>);
			<span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info($(<span class="hljs-keyword">this</span>));
		&#125;
      &#125;);
      data[key] = $.html();
    &#125;
  &#125;
&#125;);</code></pre></div>



<h3 id="三、md文章中插入图片"><a href="#三、md文章中插入图片" class="headerlink" title="三、md文章中插入图片"></a>三、md文章中插入图片</h3><p>1、直接把图片拖进md文件，会自动生成以下代码，但这只支持hexo3.0以下的</p>
<div class="hljs"><pre><code class="hljs markdown">![](image.jpg)</code></pre></div>

<p>2、hexo3.0以上的语法是</p>
<div class="hljs"><pre><code class="hljs markdown">&#123;% asset_img image.jpg This is an image %&#125;

<span class="hljs-section">#其中image.jpg为你要插入的图片名，This is an image为图片的说明</span></code></pre></div>

]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_03从尾到头打印链表</title>
    <url>/2019/11/28/%E5%89%91%E6%8C%87offer-03%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>采用递归方法，一直递归到最后一个节点，然后从最后一个点的值开始添加到列表上，直到回溯完成，列表里的存储的元素就是链表尾的元素到头的元素。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-comment">#定义一个节点类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, item,next=None)</span>:</span>
        self.item = item        <span class="hljs-comment">#定义元素</span>
        self.next = <span class="hljs-literal">None</span>        <span class="hljs-comment">#定义指针</span>

<span class="hljs-comment">#定义一个列表存储元素</span>
array_list=[]


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(listNode)</span>:</span>
    <span class="hljs-keyword">if</span> listNode:
        printListFromTailToHead(listNode.next)  <span class="hljs-comment">#递归</span>
        array_list.append(listNode.item)        <span class="hljs-comment">#取节点的元素</span>
    <span class="hljs-keyword">return</span> array_list


LN=Node(<span class="hljs-number">1</span>)      <span class="hljs-comment">#定义节点LN的元素为1</span>
LN_1=Node(<span class="hljs-number">2</span>)    <span class="hljs-comment">#定义节点LN_1的元素为2</span>
LN_2=Node(<span class="hljs-number">3</span>)    <span class="hljs-comment">#定义节点LN_2的元素为3</span>
LN.next=LN_1            <span class="hljs-comment">#把节点LN_1连接到LN后面</span>
LN_1.next=LN_2            <span class="hljs-comment">#把节点LN_2连接到LN_1后面</span>

<span class="hljs-comment">#形成了LN——&gt;LN_1——&gt;LN_2的一个链表，值分别是1，2，3</span>

print(printListFromTailToHead(LN))
<span class="hljs-comment">#输出的array_list列表为[3,2,1]</span></code></pre></div>



]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_02替换空格</title>
    <url>/2019/11/28/%E5%89%91%E6%8C%87offer-02%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>replace函数直接替换</p>
<p>replace（“old”，“new”，max），其中max是替换次数，可不填</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(s)</span>:</span>
    s=s.replace(<span class="hljs-string">" "</span>,<span class="hljs-string">"%20"</span>)		
   <span class="hljs-comment"># s="%20".join(list(s.split(" ")))		#或者字符串以空格来进行切片，然后再填充%20</span>
    <span class="hljs-keyword">return</span> s


string=<span class="hljs-string">"We are happy"</span>

print(replaceSpace(string))</code></pre></div>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_01二维数组中的查找</title>
    <url>/2019/11/28/%E5%89%91%E6%8C%87offer-01%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先我们选择从左下角开始搜寻，（为什么不从左上角开始搜寻，因为左上角向右和向下都是递增，那么对于一个点，对于向右和向下就会产生一个岔路；如果选择从左下角开始搜寻，如果大于就右，小于就向上），当然也可以从右上角开始搜寻。</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matrix_find</span><span class="hljs-params">(target,matrix)</span>:</span>
    rows=len(matrix)<span class="hljs-number">-1</span>        <span class="hljs-comment">#行长减1</span>
    cols=len(matrix[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>        <span class="hljs-comment">#列长减1</span>

    i=rows          <span class="hljs-comment">#从matrix的左下角开始</span>
    j=<span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> j&lt;=cols <span class="hljs-keyword">and</span> i&gt;=<span class="hljs-number">0</span>:          <span class="hljs-comment">#判断是否超过边界</span>
        <span class="hljs-keyword">if</span> target&lt;matrix[i][j]:     <span class="hljs-comment">#小于，则i-1，即上移</span>
            i-=<span class="hljs-number">1</span>
        <span class="hljs-keyword">elif</span> target&gt;matrix[i][j]:       <span class="hljs-comment">#大于，则j+1，即右移</span>
            j+=<span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>



a = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<span class="hljs-number">4</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]]
b = <span class="hljs-number">3</span>

print(matrix_find(b,a))</code></pre></div>



<p>二维数组如下：</p>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-物理层</title>
    <url>/2019/11/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h5 id="数据通信系统三大部分："><a href="#数据通信系统三大部分：" class="headerlink" title="数据通信系统三大部分："></a>数据通信系统三大部分：</h5><p>信源、信宿、通信媒体</p>
<p>通信的<strong>目的</strong>是传递消息</p>
<p><strong>数据</strong>是运送消息的<strong>实体</strong></p>
<h5 id="码元："><a href="#码元：" class="headerlink" title="码元："></a>码元：</h5><p>代表不同离散数值的基本波形</p>
<h5 id="三种通信方式："><a href="#三种通信方式：" class="headerlink" title="三种通信方式："></a>三种通信方式：</h5><p>1⃣️单工通信</p>
<p>2⃣️半双工通信</p>
<p>3⃣️全双工通信</p>
<p>模拟数据编码：ASK、PSK、FSK</p>
<p>模拟信号——(PCM脉冲编码)——&gt;数字信号</p>
<h5 id="PCM的工作："><a href="#PCM的工作：" class="headerlink" title="PCM的工作："></a>PCM的工作：</h5><p>采样、量化、编码</p>
<h5 id="奈氏准则："><a href="#奈氏准则：" class="headerlink" title="奈氏准则："></a>奈氏准则：</h5><p>在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的<strong>码间串扰问题</strong>，使接收端对码元的判决成为<strong>不可能</strong>。理想下的最高速率为2W Baud，W为带宽</p>
<h5 id="香农公式："><a href="#香农公式：" class="headerlink" title="香农公式："></a>香农公式：</h5><p>信道的极限传输速率C=W*log2（1+S/N）   其中W为带宽，S为平均功率，N为噪声功率，S/N为信噪比。即信道的带宽或信噪比越大，极限传输速率就越高</p>
<h5 id="传输介质："><a href="#传输介质：" class="headerlink" title="传输介质："></a>传输介质：</h5><ul>
<li>导向型（双绞线，同轴电缆）</li>
<li>非导向型（微波、卫星通信）</li>
</ul>
<h5 id="信道复用技术："><a href="#信道复用技术：" class="headerlink" title="信道复用技术："></a>信道复用技术：</h5><ul>
<li>频分复用FDM：划分不同频带，同一时间占用不同的带宽资源</li>
<li>时分复用TDM：不同时间占用同样的频带宽度（还有同步时分复用）</li>
<li>统计时分复用STDM（异步时分复用）</li>
<li>波分复用WDM：即光的频分复用</li>
<li>码分复用CDM：同一时间同一信道带宽，用不同的码型</li>
</ul>
<h5 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h5><p>在连接建立后到连接释放前全程占用信道资源（必须面向连接）</p>
<h5 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h5><p>在数据传送时占用信道资源（面向连接或无连接）</p>
<h5 id="异步通信："><a href="#异步通信：" class="headerlink" title="异步通信："></a>异步通信：</h5><p>发送端可以在任意时刻开始发送字符，且每个字符要加上开始位和停止位，接收端必须时刻做好接收准备</p>
<h5 id="同步通信："><a href="#同步通信：" class="headerlink" title="同步通信："></a>同步通信：</h5><p>通信双方必须建立同步，即双方的时钟调整到同一频率，两种同步方式，全网同步、准同步</p>
<h5 id="主要设备："><a href="#主要设备：" class="headerlink" title="主要设备："></a>主要设备：</h5><p>转发器、中继器、集线器、调制解调器</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-基础概念</title>
    <url>/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h5 id="互联网的组成："><a href="#互联网的组成：" class="headerlink" title="互联网的组成："></a>互联网的组成：</h5><p>资源子网、通信子网</p>
<h5 id="通信方式："><a href="#通信方式：" class="headerlink" title="通信方式："></a>通信方式：</h5><p>客户-服务器方式，对等方式（p2p）方式</p>
<p>路由器则是用来转发分组的，即进行分组交换</p>
<h5 id="计算机网络的定义："><a href="#计算机网络的定义：" class="headerlink" title="计算机网络的定义："></a>计算机网络的定义：</h5><p>即一些互相连接的、自治的计算机集合</p>
<h5 id="按照网络的作用范围进行分类："><a href="#按照网络的作用范围进行分类：" class="headerlink" title="按照网络的作用范围进行分类："></a>按照网络的作用范围进行分类：</h5><p>广域网WAN、城域网MAN、局域网LAN、个人局域网PAN</p>
<h5 id="网络性能指标："><a href="#网络性能指标：" class="headerlink" title="网络性能指标："></a>网络性能指标：</h5><p>1⃣️速率：数据的传送速率 bit／s</p>
<p>2⃣️带宽：用来表示网络中某通道传送数据的能力 bit／s</p>
<p>3⃣️吞吐量：表示在单位时间内通过某个网络（信道、接口）的实际的数据量</p>
<p>4⃣️时延：发送时延=数据帧长度／发送速率，传播时延=信道长度／传播速率，处理时延，排队时延<br>总时延=发送时延+传播时延+处理时延+排队时延</p>
<p>5⃣️时延带宽积=传播时延*带宽</p>
<p>6⃣️往返时间RTT</p>
<p>7⃣️利用率：D=D。／1-U     D表示当前的时延，D。表示空闲的时延，U表示利用率</p>
<p>信道或网络的<strong>利用率过高</strong>会产生非常大的<strong>时延</strong></p>
<p><strong>体系结构</strong>是计算机网络的各层及其协议的<strong>集合</strong></p>
<h5 id="协议三要素："><a href="#协议三要素：" class="headerlink" title="协议三要素："></a>协议三要素：</h5><p>语法、语义、同步</p>
<h5 id="OSI七层协议："><a href="#OSI七层协议：" class="headerlink" title="OSI七层协议："></a>OSI七层协议：</h5><p>物理层、数据链路层、网络层、运输层、会话层、表示层、应用层</p>
<h5 id="TCP／IP的四层协议："><a href="#TCP／IP的四层协议：" class="headerlink" title="TCP／IP的四层协议："></a>TCP／IP的四层协议：</h5><p>网络接口层、网际层（IP）、运输层（TCP或UDP）、应用层（各种应用层协议）</p>
<h5 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h5><table>
<thead>
<tr>
<th>各层</th>
<th align="center">物理层</th>
<th>数据链路层</th>
<th>网络层</th>
<th>运输层</th>
<th>应用层</th>
</tr>
</thead>
<tbody><tr>
<td>各层的基础设备</td>
<td align="center">中继器、转发器、集线器、调制解调器</td>
<td>网桥、二层交换机</td>
<td>三层交换机、路由器</td>
<td>传输网关</td>
<td>应用网关</td>
</tr>
<tr>
<td>各层的数据基本单位</td>
<td align="center">比特流</td>
<td>数据帧</td>
<td>数据分组</td>
<td>数据报</td>
<td>报文</td>
</tr>
</tbody></table>
<p>OSI在对等层次之间传送的数据单位称为<strong>协议数据单元（PDU）</strong></p>
<h5 id="协议和服务："><a href="#协议和服务：" class="headerlink" title="协议和服务："></a>协议和服务：</h5><p>协议的实现保证了能够向上一层提供服务，使用本层服务的实体只能看见服务，无法看见下面的协议，即下面的协议对上面的实体是<strong>透明的</strong></p>
<h5 id="各层的协议分布图："><a href="#各层的协议分布图：" class="headerlink" title="各层的协议分布图："></a>各层的协议分布图：</h5><img src="/2019/11/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/1.png" srcset="/img/loading.gif" class title="picture">]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统面试准备</title>
    <url>/2019/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h5 id="线程间通信的方法："><a href="#线程间通信的方法：" class="headerlink" title="线程间通信的方法："></a>线程间通信的方法：</h5><p>同一进程的各线程可以直接读写进程数据段进行通信，同时，需要同步和互斥手段的辅助，而不同进程间的线程通信可以参考不同进程间的通信</p>
<h5 id="多线程同步方式："><a href="#多线程同步方式：" class="headerlink" title="多线程同步方式："></a>多线程同步方式：</h5><p>事件event，临界区域，互斥器、信号量</p>
<h5 id="同步和异步的区别："><a href="#同步和异步的区别：" class="headerlink" title="同步和异步的区别："></a>同步和异步的区别：</h5><p>同步是阻塞模式，即发送方发出数据后，等待接受法发回响应以后才发送下一个数据包的通讯方式；异步是非阻塞方式，发送方发出数据后，不等接收方发回响应，接着发送下一个数据包的通讯方式</p>
<h5 id="普通B-S模式（同步）AJAX技术（异步）"><a href="#普通B-S模式（同步）AJAX技术（异步）" class="headerlink" title="普通B/S模式（同步）AJAX技术（异步）"></a>普通B/S模式（同步）AJAX技术（异步）</h5><p>同步：提交请求—&gt;等待服务器处理—&gt;处理完毕返回 。这期间客户端浏览器不能干任何事<br>异步：请求通过事件触发—&gt;服务器处理（这时浏览器可以做其他事情）—&gt;处理完毕</p>
<h5 id="进程和线程的概念："><a href="#进程和线程的概念：" class="headerlink" title="进程和线程的概念："></a>进程和线程的概念：</h5><h6 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h6><p>是操作系统结构的基础，进程是一个程序的一次执行过程；是一个正在执行的程序；计算机中正在运行的程序实例；可以分配给处理器并由处理器执行的一个实体；由单一顺序的执行显示，一个当前状态和一组相关的系统资源所描述的活动单元</p>
<h6 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h6><p>有时被称为轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针(PC)，寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是呗系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可以与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性，线程也有就绪、阻塞和运行三种基本状态</p>
<h5 id="进程和线程的区别："><a href="#进程和线程的区别：" class="headerlink" title="进程和线程的区别："></a>进程和线程的区别：</h5><p>子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文，多线程主要是为了节约CPU事件，发挥利用。根据具体情况而定，线程的运行中需要使用计算机的内存资源和CPU。通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在进入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位</p>
<h5 id="进程的地址空间是怎么回事？虚拟内存是如何实现的？"><a href="#进程的地址空间是怎么回事？虚拟内存是如何实现的？" class="headerlink" title="进程的地址空间是怎么回事？虚拟内存是如何实现的？"></a>进程的地址空间是怎么回事？虚拟内存是如何实现的？</h5><p>虚拟内存的存在使得CPU上的指令访问的地址都是虚拟地址，而这些地址是需要在物理内存中真实存在的，这里就需要在虚拟地址和物理地址直接建立一个映射关系（应当是多对一的关系），说白了就是一个整数集合到另一个整数集合的映射。然后在查找时，根据相应的算法（如先进先出，最多使用等）进行调度</p>
<h5 id="死锁的定义："><a href="#死锁的定义：" class="headerlink" title="死锁的定义："></a>死锁的定义：</h5><p>​    死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进</p>
<h5 id="死锁产生的原因："><a href="#死锁产生的原因：" class="headerlink" title="死锁产生的原因："></a>死锁产生的原因：</h5><p>​    1、系统资源的竞争<br>​    2、进程运行推进顺序不合适</p>
<h5 id="产生死锁有四个必要条件："><a href="#产生死锁有四个必要条件：" class="headerlink" title="产生死锁有四个必要条件："></a>产生死锁有四个必要条件：</h5><p>1、互斥条件。一个资源只能被一个进程占用<br>2、不可剥夺条件。某个进程占用了资源，就只能他自己去释放。<br>3、请求和保持条件。某个进程之前申请了资源，我还想再申请资源，之前的资源还是我占用着，别人别想动。除非我自己不想用了，释放掉。<br>4、循环等待条件。一定会有一个环互相等待。</p>
<h5 id="死锁避免和预防："><a href="#死锁避免和预防：" class="headerlink" title="死锁避免和预防："></a>死锁避免和预防：</h5><h6 id="1、死锁避免"><a href="#1、死锁避免" class="headerlink" title="1、死锁避免"></a>1、死锁避免</h6><p>死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。</p>
<h6 id="2、死锁预防"><a href="#2、死锁预防" class="headerlink" title="2、死锁预防"></a>2、死锁预防</h6><p>1⃣️破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。<br>2⃣️破坏”请求与保持条件“：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。<br>3⃣️破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。</p>
<h5 id="linux进程间通信有哪些方式，优缺点如何"><a href="#linux进程间通信有哪些方式，优缺点如何" class="headerlink" title="linux进程间通信有哪些方式，优缺点如何"></a>linux进程间通信有哪些方式，优缺点如何</h5><h6 id="管道-pipe-："><a href="#管道-pipe-：" class="headerlink" title="管道( pipe )："></a>管道( pipe )：</h6><p>管道包括三种:<br>1⃣️普通管道PIPE： 通常有两种限制,一是单工,只能单向传输;二是只能在父子或者兄弟进程间使用.<br>2⃣️流管道s_pipe: 去除了第一种限制,为半双工，只能在父子或兄弟进程间使用，可以双向传输.<br>3⃣️命名管道:name_pipe：去除了第二种限制,可以在许多并不相关的进程之间进行通讯.</p>
<h6 id="信号量-semophore-："><a href="#信号量-semophore-：" class="headerlink" title="信号量( semophore ) ："></a>信号量( semophore ) ：</h6><p>​    信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<h6 id="消息队列-message-queue-："><a href="#消息队列-message-queue-：" class="headerlink" title="消息队列( message queue ) ："></a>消息队列( message queue ) ：</h6><p>​    消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<h6 id="信号-sinal-："><a href="#信号-sinal-：" class="headerlink" title="信号 ( sinal ) ："></a>信号 ( sinal ) ：</h6><p>​    信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<h6 id="共享内存-shared-memory-："><a href="#共享内存-shared-memory-：" class="headerlink" title="共享内存( shared memory ) ："></a>共享内存( shared memory ) ：</h6><p>​    共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>
<h6 id="套接字-socket-："><a href="#套接字-socket-：" class="headerlink" title="套接字( socket ) ："></a>套接字( socket ) ：</h6><p>​    套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2019/11/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="请列举常用的排序算法"><a href="#请列举常用的排序算法" class="headerlink" title="请列举常用的排序算法"></a>请列举常用的排序算法</h4><p>并说明其时间复杂度，并说明排序思路</p>
<h5 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h5><p>两两比较待排序数据元素的大小，发现两个数据元素的次序相反时即进行交换，直到没有反序的数据元素位置，算法时间复杂度是O(n^2)</p>
<h5 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h5><p>每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序数据元素全部插入完为止，算法时间复杂度是O(n^2)</p>
<h5 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h5><p>每次将一个待排序的数据元素，插入到前面已经排好序的数列中的适当位置，使数列依然有序；直到待排序数据元素全部插入完为止，算法复杂度是O(n^2)</p>
<h5 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h5><p>在当前无序区R[1，H]中任取一个数据元素作为比较的“基准”，用此基准将当前无序区划分为左右两个较小的无序区：R[1，i-1] 和R[i+1，H]，且左边的无序子区中数据元素均小于或等于基准元素，右边的无序子区中数据元素均大于等于基准元素，而且该基准位于最终排序的位置上，即R[1，i-1]&lt;= 基准&lt;=R[i+1，H]，当R[1，i-1]和R[i+1，H]均非空时，分别对它们进行上述的划分过程，直至所有无序子区中的数据元素均已排序为止。该排序为不稳定排序，最理想的算法时间复杂度O(nlog2n)，最坏O(n^2)</p>
<h5 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h5><p>堆排序是一树形选择排序，在排序过程中，将R[1，N]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素，算法时间复杂度O(nlogn)</p>
<h5 id="希尔排序："><a href="#希尔排序：" class="headerlink" title="希尔排序："></a>希尔排序：</h5><p>其实就是用步长控制的插入排序，希尔排序通过加大插入排序中元素之间的间隔，并在这些有间隔的元素中进行插入排序，从而让数据项可以大幅度移动，这样的方式使每次移动之后的数据离他们在最终序列中的位置相差不大，保证数据的基本有序，大大提升了排序速度，运算时间复杂度是O(n*logn)</p>
<h5 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h5><p>​    DIvide：把长度为n的输入序列分成两个长度为n／2的子序列。<br>​    Conquer：对这两个子序列分别采用归并排序<br>​    Combine：将两个排序好的子序列合并成一个最终的排序序列<br>时间复杂度是O(nlog2n)</p>
<h4 id="快速排序的多种复杂度"><a href="#快速排序的多种复杂度" class="headerlink" title="快速排序的多种复杂度"></a>快速排序的多种复杂度</h4><p>平均时间复杂度是多少？最坏时间复杂度是什么？在哪些情况下会遇到最坏的时间复杂度？</p>
<p>​    快速排序的平均时间复杂度O(nlog2n)，最坏时间复杂度O(n^2)<br>​    最坏情况：当每次pivot选择恰好都把列表元素分成（1，n-1）<br>​    采取措施：pivot的选取是通过random来进行</p>
<h4 id="各排序算法的稳定性"><a href="#各排序算法的稳定性" class="headerlink" title="各排序算法的稳定性"></a>各排序算法的稳定性</h4><h5 id="不稳定排序："><a href="#不稳定排序：" class="headerlink" title="不稳定排序："></a>不稳定排序：</h5><p>选择排序、快速排序、希尔排序、堆排序</p>
<h5 id="稳定排序："><a href="#稳定排序：" class="headerlink" title="稳定排序："></a>稳定排序：</h5><p>冒泡排序、插入排序、归并排序和基数排序</p>
<h4 id="一张图总结"><a href="#一张图总结" class="headerlink" title="一张图总结"></a>一张图总结</h4><img src="/2019/11/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/suanfa.jpg" srcset="/img/loading.gif" class title="总结">



]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊区块字段和交易字段</title>
    <url>/2019/11/23/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8C%BA%E5%9D%97%E5%AD%97%E6%AE%B5%E5%92%8C%E4%BA%A4%E6%98%93%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<p>见图1</p>
<img src="/2019/11/23/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8C%BA%E5%9D%97%E5%AD%97%E6%AE%B5%E5%92%8C%E4%BA%A4%E6%98%93%E5%AD%97%E6%AE%B5/1.jpg" srcset="/img/loading.gif" class title="图1">

<ul>
<li><p>Difficulty：表示当前区块的难度。</p>
</li>
<li><p>ExtraData：与此区块相关的附加数据。</p>
</li>
<li><p>gasLimit：当前区块允许使用的最大gas。</p>
</li>
<li><p>gasUsed：当前区块累计使用的gas。</p>
</li>
<li><p>Hash：区块的哈希值。如果区块没有被确认，这个字段会是null值。</p>
</li>
<li><p>LogsBloom：区块日志的布隆过滤器，区块没被确认是值为null。 </p>
</li>
<li><p>Miner：取得该区块记账权的矿工。</p>
</li>
<li><p>mixHash：一个Hash值，当与nonce组合时，证明此区块已经执行了足够的计</p>
<p>算。</p>
</li>
<li><p>nonce：POW生成的哈希值。</p>
</li>
<li><p>Number：区块号。</p>
</li>
<li><p>parentHash：前一个区块的哈希值。</p>
</li>
<li><p>receiptsRoot：收据树的根哈希值。</p>
</li>
<li><p>Sha3Uncles：数据块的哈希值。</p>
</li>
<li><p>Size：当前区块的字节大小。</p>
</li>
<li><p>stateRoot：区块状态树的根哈希。</p>
</li>
<li><p>Timestamp：区块打包时的unix时间戳。</p>
</li>
<li><p>totalDifficulty：区块链到当前区块的总难度。</p>
</li>
<li><p>Transactions：交易的对象。</p>
</li>
<li><p>transactionsRoot：区块的交易树的根哈希。</p>
</li>
<li><p>Uncles：叔哈希的数组。</p>
</li>
</ul>
<p>  见图2</p>
  <img src="/2019/11/23/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%8C%BA%E5%9D%97%E5%AD%97%E6%AE%B5%E5%92%8C%E4%BA%A4%E6%98%93%E5%AD%97%E6%AE%B5/2.jpg" srcset="/img/loading.gif" class title="图2">

<ul>
<li>blockHash：这个交易所在的块的哈希值。</li>
<li>blockNumber：这个交易所在的块的编号。</li>
<li>from：发起这个交易的账户或者用户。</li>
<li>gas：执行这个交易所需要的gas。</li>
<li>gasPrice：当前gas与以太币换算的汇率。</li>
<li>hash：当前这个交易的哈希值。</li>
<li>input：这里是部署智能合约的交易，所以这里的input是合约的16进制代码。</li>
<li>nonce：这里的是交易下的nonce值，是账户发起交易所维护的nonce，一个交易对应一个nonce值，注意区分区块中的nonce，区块中的nonce是用于POW的nonce。</li>
<li>r，v，s：交易签名和用去决定交易的发送者的对应值。</li>
<li>to：交易接收着的地址。这里是合约的创建，合约账户的地址还没有，所以是null。</li>
<li>transactionIndex：这个交易在其对应区块的序号。</li>
<li>value：指交易要给交易接收着发送的以太币数量。</li>
</ul>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试面试准备</title>
    <url>/2019/11/23/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h4 id="测试方法："><a href="#测试方法：" class="headerlink" title="测试方法："></a>测试方法：</h4><h5 id="黑盒测试："><a href="#黑盒测试：" class="headerlink" title="黑盒测试："></a>黑盒测试：</h5><p>等价类划分、边界值分析、错误检测法</p>
<h5 id="白盒测试："><a href="#白盒测试：" class="headerlink" title="白盒测试："></a>白盒测试：</h5><p>逻辑覆盖法，主要包括语句覆盖、判断覆盖、条件覆盖、判断条件覆盖、条件组合覆盖、路径覆盖</p>
<h5 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h5><p>​    不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符合执行来找错误。</p>
<h5 id="动态测试："><a href="#动态测试：" class="headerlink" title="动态测试："></a>动态测试：</h5><p>​    通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率和健壮性等性能，这种方法由三部分组成：构造测试实例、执行程序、分析程序的输出结果。分为五个步骤：单元测试、集成测试、系统测试、验收测试、回归测试</p>
<h4 id="等价类划分："><a href="#等价类划分：" class="headerlink" title="等价类划分："></a>等价类划分：</h4><h5 id="有效等价类和无效等价类"><a href="#有效等价类和无效等价类" class="headerlink" title="有效等价类和无效等价类"></a>有效等价类和无效等价类</h5><p>​    有效等价类：对程序的规格说明有意义的，合理的输入数据所构成的集合，利用有效等价类可以验证程序是否实现了规格说明书中的功能和性能<br>​    无效等价类：那些对程序的规格说明不合理或无意义的数据所构成的，为了验证程序做其不应该做的事情</p>
<h5 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h5><p>​     优点：考虑了单个数据域的各类情况，避免盲目或随机地选取输入数据的不完整性和不稳定性，同时可有效控制测试设计的数量<br>​     缺点：对组合情况考虑不足，同时等价类划分基于等价类中的输入都能产生相同的效果，在很多情况下用例选择不当会产生问题（如边界）</p>
<h5 id="等价类划分的原则："><a href="#等价类划分的原则：" class="headerlink" title="等价类划分的原则："></a>等价类划分的原则：</h5><p>​    1⃣️在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类<br>​    2⃣️在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立一个有效等价类和一个无效等价类<br>​    3⃣️在输入条件是布尔量的情况下，可以确定一个有效类和一个无效类<br>​    4⃣️在规定了输入数据的一组值，并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类<br>​    5⃣️在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类和若干个无效等价类<br>​    6⃣️在确定已知的等价类中各元素在程序处理中的方法不同的情况下，则应再将等价类进一步划分为更小的等价类</p>
<h4 id="边界值测试："><a href="#边界值测试：" class="headerlink" title="边界值测试："></a>边界值测试：</h4><h5 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a>优缺点：</h5><p>​    长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出的范围内，因此针对各种边界值情况设计测试用例，可以查出更多的错误<br>​    不过边界值分析法与等价类划分法一样，没有考虑输入之间的组合情况，因此需要进一步结合其他测试用例设计方法。</p>
<h4 id="性能测试：如何评价系统的极限性能？"><a href="#性能测试：如何评价系统的极限性能？" class="headerlink" title="性能测试：如何评价系统的极限性能？"></a>性能测试：如何评价系统的极限性能？</h4><p>基本点：并发度、响应时间、单位时间吞吐量、系统稳定性、多场景<br>加分点：新旧版本对比，性能瓶颈分析方法（雪崩、线性拐点等）</p>
<h4 id="判断测试活动中止的条件："><a href="#判断测试活动中止的条件：" class="headerlink" title="判断测试活动中止的条件："></a>判断测试活动中止的条件：</h4><p>​    1⃣️无新发生bug且严重性高的bug已经修复</p>
<p>​    2⃣️bug收敛</p>
<p>​    3⃣️某一级别bug低于一定比例</p>
<p>​    4⃣️时间耗尽</p>
<p>​    5⃣️满足特定覆盖率，</p>
<h4 id="常见的软件测试模型："><a href="#常见的软件测试模型：" class="headerlink" title="常见的软件测试模型："></a>常见的软件测试模型：</h4><p>V模型、W模型、H模型、X模型和前置模型</p>
<h5 id="杯子测试（校招）"><a href="#杯子测试（校招）" class="headerlink" title="杯子测试（校招）"></a>杯子测试（校招）</h5><p>答案：冒烟测试：速度装一杯水，是否漏水<br>            功能测试：漏水测试、透明度测试、卫生情况测试、杯口平滑测试、重量测试、均匀度测试<br>            压力测试：抗摔测试，抗高温测试</p>
<h5 id="题目：百度首页是由模版展现的，请问如何对它进行测试"><a href="#题目：百度首页是由模版展现的，请问如何对它进行测试" class="headerlink" title="题目：百度首页是由模版展现的，请问如何对它进行测试"></a>题目：百度首页是由模版展现的，请问如何对它进行测试</h5><p>（不考虑性能相关因素，建议多从用户行为和使用环境角度进行测试）</p>
<p>答案：<br>    展现检查：文字图片内容，链接，一致性<br>    数据传递：字符串长短与截断；特殊字符；中英文；空格；下拉条提示<br>    兼容性检查：不同浏览器，不同操作系统，不同分辨率<br>    用户行为：窗口拉大，缩小；字号大小，编码格式，刷新，前进后退</p>
<h5 id="请问BAIDU-HI聊天消息收发的测试思路"><a href="#请问BAIDU-HI聊天消息收发的测试思路" class="headerlink" title="请问BAIDU HI聊天消息收发的测试思路"></a>请问BAIDU HI聊天消息收发的测试思路</h5><p>答案：从 正常测试、异常测试、不同的消息类型、组合测试、长度极值、是否延迟、是否丢失、是否被篡改、安全性</p>
]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>面试准备</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年百度秋招补招面试</title>
    <url>/2019/11/22/2019%E5%B9%B4%E7%99%BE%E5%BA%A6%E7%A7%8B%E6%8B%9B%E8%A1%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>下午两点百度科技园2号楼进行面试，</p>
<p>​        上来就自我介绍，之后HR就开始问我项目的事情，因为我简历上的项目都是区块链相关的，HR对这方面了解的不是很多，所以没有怎么追根到底地问。据说，一般HR会对简历上写的项目追根到底的问，问你这个项目是怎么做的，用了那些东西，这些东西的原理是什么？</p>
<hr>
<p>一面：</p>
<p>HR：<strong>如何用一行代码实现1+2+3……+100?</strong></p>
<p>我：</p>
<div class="hljs"><pre><code class="hljs python">print((<span class="hljs-number">1</span>+<span class="hljs-number">100</span>)*<span class="hljs-number">100</span>/<span class="hljs-number">2</span>)
print(sum([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>)]))</code></pre></div>

<p>HR:<strong>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</strong>例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p>我：遍历统计，记录每个元素出现的次数，然后找出出现次数超过一半的那个数</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">traverseEach</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">array</span>,<span class="hljs-keyword">int</span> number)</span> </span>&#123;
     
    <span class="hljs-keyword">int</span> *tempArray = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*(number / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>);
     
    <span class="hljs-comment">//全部初始化为0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number * <span class="hljs-number">2</span>; i ++) &#123;
        tempArray[i] = <span class="hljs-number">0</span>;
    &#125;
     
    <span class="hljs-keyword">int</span> maxNumber = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> returnValue = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> maxCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> tempIndex = <span class="hljs-number">0</span>;
     
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i ++) &#123;
         
        tempIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (maxCount == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">//初始化一下</span>
            tempArray[maxCount] = <span class="hljs-built_in">array</span>[i];
            tempArray[number + i] = <span class="hljs-number">1</span>;
            maxCount = <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">//</span>
            <span class="hljs-keyword">for</span> (; tempIndex &lt; maxCount; tempIndex ++) &#123;
                <span class="hljs-keyword">if</span> (tempArray[tempIndex] == <span class="hljs-built_in">array</span>[i]) &#123;
                    tempArray[number + tempIndex] += <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (tempIndex == maxCount) &#123;
                <span class="hljs-comment">//新的</span>
                tempArray[tempIndex] = <span class="hljs-built_in">array</span>[i];
                tempArray[number + tempIndex] += <span class="hljs-number">1</span>;
                maxCount += <span class="hljs-number">1</span>;
            &#125;
        &#125;
         
        <span class="hljs-keyword">if</span> (maxNumber &lt; tempArray[number + tempIndex]) &#123;
            maxNumber = tempArray[number + tempIndex];
            returnValue = tempArray[tempIndex];
        &#125;
    &#125;
     
    <span class="hljs-built_in">free</span>(tempArray);
    <span class="hljs-comment">//检验是否大于一半</span>
    <span class="hljs-keyword">if</span> (maxNumber &lt;= number/<span class="hljs-number">2</span>) &#123;
        returnValue = <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-keyword">return</span> returnValue;
&#125;</code></pre></div>

<p>HR:能不能来个简单一点的方法？</p>
<p>我：可以进行排序，因为这个数出现次数超过了一半，所以中间那个数肯定就是要求的了</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">maopSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">array</span>,<span class="hljs-keyword">int</span> number)</span> </span>&#123;
    <span class="hljs-keyword">int</span> changed = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = number - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span> ; i --) &#123;
        <span class="hljs-keyword">if</span> (changed == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        changed = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[j] &gt; <span class="hljs-built_in">array</span>[j+<span class="hljs-number">1</span>]) &#123;
                <span class="hljs-comment">//exchange</span>
                <span class="hljs-built_in">array</span>[j] += <span class="hljs-built_in">array</span>[j+<span class="hljs-number">1</span>];
                <span class="hljs-built_in">array</span>[j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">array</span>[j] - <span class="hljs-built_in">array</span>[j+<span class="hljs-number">1</span>];
                <span class="hljs-built_in">array</span>[j] = <span class="hljs-built_in">array</span>[j] - <span class="hljs-built_in">array</span>[j+<span class="hljs-number">1</span>];
                changed = <span class="hljs-number">1</span>;
            &#125;
        &#125;
    &#125;
&#125;
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sortRelu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">array</span>, <span class="hljs-keyword">int</span> number)</span></span>&#123;
    maopSort(<span class="hljs-built_in">array</span>, number);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">array</span>[number/<span class="hljs-number">2</span>];
&#125;</code></pre></div>

<p>HR:那万一这个数没有出现一半呢？怎么办？</p>
<p>我：那遍历时，进行比较，从列表中移除两个不相等的数字，一直到只剩下最后一个数，那个数就是所求</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">neutralize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">array</span>,<span class="hljs-keyword">int</span> number)</span> </span>&#123;
     
    <span class="hljs-keyword">int</span> returnValue = <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
     
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; number; i ++) &#123;
        <span class="hljs-keyword">if</span> (returnValue == <span class="hljs-built_in">array</span>[i]) &#123;
            count += <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            count -= <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;
            count = <span class="hljs-number">1</span>;
            returnValue = <span class="hljs-built_in">array</span>[i];
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> returnValue;
&#125;</code></pre></div>

<p>HR:<strong>一行代码实现列表的遍历</strong></p>
<p>我：</p>
<div class="hljs"><pre><code class="hljs python">print([[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>)][i:i+<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>)])</code></pre></div>

<p>HR:<strong>一行代码实现将 1-N 的整数列表以 3为单位分组</strong></p>
<p>我：</p>
<div class="hljs"><pre><code class="hljs c"><span class="hljs-built_in">print</span>([[x <span class="hljs-keyword">for</span> x in range(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>)][i:i+<span class="hljs-number">3</span>] <span class="hljs-keyword">for</span> i in range(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>,<span class="hljs-number">3</span>)])</code></pre></div>

<p>HR：<strong>数据库操作，从students表里面，查询一下相同名字的人数</strong></p>
<p>我：</p>
<div class="hljs"><pre><code class="hljs mysql">select name，count(*) from students group by name having count(*)&gt;1</code></pre></div>

<p>HR:<strong>Linux命令熟悉吧，你写几个，然后讲一下，拓展一下</strong></p>
<p>我：ls、find 、cd、tree、cp、mv、pwd、tar、mkdir、rmdir、gzip、ps、kill、crontab、free、chmod</p>
<p>然后HR挑了几个来问我，用这个命令实现什么什么功能，要加什么参数</p>
<p>HR：<strong>说下计算机网络的OSI七层模型吧</strong></p>
<p>我：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<p>HR：<strong>回文知道吧，你写一下代码实现一下。</strong></p>
<p>我：</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    str=input(<span class="hljs-string">"请输入字符串:"</span>)		<span class="hljs-comment">#输入一个字符串</span>
    length=len(str)			<span class="hljs-comment">#求字符串长度</span>
    left=<span class="hljs-number">0</span>			<span class="hljs-comment">#定义左右‘指针’</span>
    right=length<span class="hljs-number">-1</span>
    <span class="hljs-keyword">while</span> left&lt;=right:		<span class="hljs-comment">#判断</span>
        <span class="hljs-keyword">if</span> str[left]==str[right]:
            left+=<span class="hljs-number">1</span>
            right-=<span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">if</span> left&gt;right:
        print(<span class="hljs-string">"是"</span>)
    <span class="hljs-keyword">else</span> :
        print(<span class="hljs-string">"不是"</span>)</code></pre></div>

<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>HR：你能用python的字符串切片实现一下吗？<br>=======<br>HR：太复杂了，你再想想简单的</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1d7a5609698e83b4ddb970e10b6b6edfcb4332fb</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>我：</p>
<div class="hljs"><pre><code class="hljs python">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span><span class="hljs-params">(text)</span>:</span>
    <span class="hljs-keyword">return</span> text[::<span class="hljs-number">1</span>]

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_palindrome</span><span class="hljs-params">(text)</span>:</span>
    <span class="hljs-keyword">return</span> text==reverse(text)

something = input(<span class="hljs-string">"请输入字符串"</span>)
<span class="hljs-keyword">if</span> is_palindrome(something):
    print(<span class="hljs-string">"是"</span>)
<span class="hljs-keyword">else</span>:
    print(<span class="hljs-string">"不是"</span>)
=======
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Ishuiwen</span><span class="hljs-params">(text)</span>:</span>
    t1=list(text)	<span class="hljs-comment">#转换成列表</span>
    t1.reverse()	<span class="hljs-comment">#倒序</span>
    t2=<span class="hljs-string">''</span>.join(t1)		<span class="hljs-comment">#加到字符串里</span>
    <span class="hljs-keyword">if</span> t2 == text:
        print(<span class="hljs-string">"是"</span>)
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">"不是"</span>)</code></pre></div>

<p>HR：你能用python的字符串切片实现一下吗？</p>
<p>我：</p>
<div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Ishuiwen</span><span class="hljs-params">(text)</span>:</span>
    t1=text[::<span class="hljs-number">-1</span>]		<span class="hljs-comment">#倒序切片</span>
    <span class="hljs-keyword">if</span> t1==text:
        print(<span class="hljs-string">"是"</span>)
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">"不是"</span>)
&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="hljs-number">1</span>d7a5609698e83b4ddb970e10b6b6edfcb4332fb</code></pre></div>

<p>HR：<strong>你看我们那个百度首页，那个输入框，你设计一下测试用例</strong></p>
<p>我：针对输入框的话：输入的字符串，以及一些奇怪的字符，输入是一张图片，是一个文件呢</p>
<p>针对页面的话：窗口放大缩小，字号放大缩小、编码格式</p>
<p>针对整个网站的话：不同的浏览器、不同的操作系统、不同的屏幕分辨率、多人同时访问</p>
<p>HR：你有什么想问我的吗？</p>
<p>然后我就随便问了下，工作具体是干嘛的</p>
<p>就这样一面结束了，然后HR叫我再等等，她去叫二面的HR过来</p>
<hr>
<p>二面</p>
<p>上来HR就介绍了一下她自己，然后再介绍了一下我所应聘的部门以及工作岗位，然后叫我自我介绍一下，然后我又重新复述了一下自我介绍，然后HR又是针对我的区块链项目无从下手，只是问了一下表面，然后没有深入。</p>
<p>HR：<strong>不借助第三个数实现下a，b值的互换</strong></p>
<p>我：</p>
<div class="hljs"><pre><code class="hljs c">a=a-b;
b=a+b;
a=b-a; #利用a,b的差值作为中间媒介来互换</code></pre></div>

<p>HR:有更简单的方法吗？</p>
<p>我想了好久，还是不知道，然后HR告诉我了，用python</p>
<div class="hljs"><pre><code class="hljs python">a,b=b,a</code></pre></div>

<p>HR:<strong>你写一下你熟悉的Linux命令吧</strong>。</p>
<p>我(心里暗暗窃喜)：ls、find 、cd、tree、cp、mv、pwd、tar、mkdir、rmdir、gzip、ps、kill、crontab、free、chmod</p>
<p>HR：<strong>你知道socket吧，在linux上启动一个，然后你要怎样查看它的端口</strong></p>
<p>我想了好久，答不出来。</p>
<p>HR：</p>
<div class="hljs"><pre><code class="hljs shell">netstat -nltp|grep XXX
lsof -i|grep XXX			#这两个命令都可以</code></pre></div>

<p>HR：<strong>我看你这写着学过C++，我们这个岗位后端就是用的C++，你说说内存泄漏的几种情况吧</strong></p>
<p>C++是大二学的，学完就没有怎么用过了，所以现在我完全不会</p>
<p>HR: 1、在类的构造函数和析构函数中没有匹配的调用new和delete函数</p>
<p>​        2、没有正确地清除嵌套的对象指针</p>
<p>​        3、 在释放对象数组时在delete中没有使用方括号</p>
<p>​        4、指向对象的指针数组不等同于对象数组</p>
<p>​        5、 缺少拷贝构造函数</p>
<p>​        6、缺少重载赋值运算符</p>
<p>​        7、没有将基类的析构函数定义为虚函数</p>
<p>HR：<strong>你这写着你也学过操作系统，那你说一下Linux中的进程通信吧</strong></p>
<p>我。。。。。。。</p>
<p>HR：管道、消息队列、信号量、共享内存、套接字</p>
<p>HR：<strong>那你说一下死锁，以及怎么解决死锁问题</strong></p>
<p>我(终于有我会的了)：死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进</p>
<p>​    死锁产生的原因：<br>​    1、系统资源的竞争<br>​    2、进程运行推进顺序不合适</p>
<p>​    产生死锁有四个必要条件：互斥条件、不可剥夺条件、请求和保持条件、循环等待条件</p>
<p>解决方法：死锁避免，先尝试分配资源，如果分配后可能出现死锁，那就不分配</p>
<p>​                    死锁预防：破坏不可剥夺条件、破坏请求和保持条件、破坏循环条件</p>
<p>HR：<strong>你有什么想问我的吗？</strong></p>
<p>我：这边面试什么时候出结果，三面还是技术面吗？</p>
<p>二面就这样结束了</p>
<hr>
<p>我因为没怎么准备，所以面得很烂，尤其是二面的时候，连续几个问题没答上来，HR估计都要放弃我了。一面面了一个多小时，二面大概就四十分钟左右。</p>
<p>结果：在我刚上西二旗地铁站，就收到百度发来的拒绝邮件。</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
</search>
